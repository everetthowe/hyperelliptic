// Hyperelliptic2.magma
// Version 2.00
// 8 June 2025

// Code related to two papers:

// [Howe2025]
// Everett W. Howe:
// Enumerating hyperelliptic curves over finite fields in quasilinear time,
// Res. number theory 11, 26 (2025). Proceedings of ANTS XVI.
// https://doi.org/10.1007/s40993-024-00594-7

// [Howe2024]
// Everett W. Howe:
// Enumerating places of P1 up to automorpshisms of P1 in quasilinear time,
// arXiv:2407.05534 [math.NT]
// https://doi.org/10.48550/arXiv.2407.05534



/* 
================================================================================
This collection of Magma routines is designed to produce a list of all genus-2
curves over a given finite field of odd characteristic, up to isomorphism. The 
strategy is to compute a complete set of unique representatives for the orbits
of PGL(2,F_q) acting on monic homogeneous separable sextic polynomials of a
given "Galois type," as defined in [Howe2025], and then producing the one or two
distinct double covers of P^1 ramified at the roots of the given polynomials.

The routines in this file have been completely rewritten since the first 
version. Some of the changes are to incorporate ideas from [Howe2024], and one
of the goals of this version is to reduce the memory requirements of the 
routines to O(q). This will be the case if one chooses to have the output
printed instead of returned in a variable.

We group the Galois types by the largest degree they include, and compute all
of the genus-2 hyperelliptic curves for each of these grouping of Galois types.
The programs for computing the curves are named for the types in the grouping:

genustwo1x()
genustwo2x()
genustwo3x()
genustwo4x()
genustwo51()
genustwo6()

We also have a combined function that runs all of the above:

hyperelliptic2()

If one is interested not in the curves but rather in the orbits of Galois-stable
sets of six elements of P^1 over the algebraic closure, one can set the
optional parameter "curves" of these functions to "false".

If one does not want the output of the functions returned in a variable, one 
can set the optional paramater "passback" to "false".

If one wants the output to be printed, one can set the optional parameter
"output" to "true". And if one wants the output printed to a file instead of
to standard out, one can set the optional paameter "outputfile" to the name
of the desired file.

When the output is returned in a variable, each element of it is a triple
<f, n, G>, where f is a polynomial, G is a finite subgroup of PGL(2,GF(q))
specified by its elements represented by matrices, and n is either #G or 
twice #G (as explained below). When the output represents a Galois-stable set
of elements of P^1, G is the stabilizer of this set in PGL(2,GF(q)) and n = #G.
When the output represents a curve, G is the image in PGL(2,GF(q)) of the
automorphism group of the curve, and n is twice the order of G, so that n is 
the order of the automorphism group of the curves.

When output is printed instead of returned in a variable, the elements are 
shortened. The polynomial f is represented by its sequence of coefficients as
given by Eltseq(f), and the group G is not listed. 


This file also includes many utility functions needed by the main programs:

function IsFrobeniusFunction(F,f)
function isomorphisms222(F,f: all:=true)
function j_quartic(g)
function mapsbetweenpairsofquadratics(pair1,pair2)
function mu_invariant(q1, q2)
function nonsquare(K)
function quarticLFTs(f,g)
function quickj4(quadruple)


automorphisms111111() : 
                  Given a set of six points in P^1(K), compute the PGL(2,K) 
                  stabilizer of the set.
                      
betaorbitreps() : Given a finite field K of odd characteristic and an element
                  beta of the quadratic extension L of K with beta^2 in K,
                  let G be the subgroup of PGL(2,K) that fixes the set
                  {beta, -beta}. Returns orbit representatives for G acting on
                  P^1(L) \ {beta, -beta}.
                  
cross()         : Given an irreducible f, compute its cross polynomial, as 
                  defined in [Howe2025]. 
                  
curves_from_divisor() :
                  Given a separable polynomial of degree 2g+1 and 2g+2 over a
                  finite field K of odd characteristic, together with the set
                  of elements of PGL(2,K) that map its set of roots to itself,
                  produce the one or two curves (and automorphism groups) with
                  these roots as Weierstrass points. 

fourpoints1111() : 
                  Given a finite field K of odd characteristic, return PGL(2,K)
                  orbit representatives for the sets of four distinct rational
                  points of P^1. Choose the representatives so that the 
                  involutions of the four points are normalized to standard
                  ones.
                   
fourpoints22()  : Given a finite field K of odd characteristic, return
                  representatives for the PGL(2,K) orbits of pairs of pairs of
                  two conjugate elements of P^1. Choose the representatives so
                  that the involutions of the pairs are normalized to standard
                  ones.

fourpoints4()   : Given a finite field K of odd characteristic, return
                  representatives for the PGL(2,K) orbits of sets of four 
                  conjugate elements of P^1. Choose the representatives so that
                  the involution of the four points is normalized to one of two
                  standard ones.

irreducible3()  : Given a finite field, produces a "standard" irreducible 
                  cubic of the form x^3 + s*x^2 - (s+3)*x + 1.
                  
isomorphisms222() : 
                  Given two sextic polynomials f and F over a finite field K,
                  each of them a product of three irreducible quadratics, 
                  return true or false depending on whether there is an 
                  element of PGL(2,K) taking one to the other.
                                       
j_quartic()     : Gives the j-invariants of the Jacobian of y^2 = f, for 
                  separable quartics and cubics f.

mapsbetweenpairsofquadratics() :
                  Given a two pairs of irreducible quadratics, returns the set
                  of elements of PGL2 that send the first pair to the second.

mu_invariant()  : Computes an invariant (defined in the paper) for pairs
                  of two irreducible quadratics.

nonsquare()     : Given a finite field, produces a nonsquare elemets, chosen
                  from the prime field if possible.

GL2reps()      : Given a finite field K of odd characteristic and a quadratic
                  extension L of K, returns orbit representatives for the left
                  action of PGL(2,K) on PGL(2,L).
                                    
PGLreduce()     : Given a 2x2 matrix representing an element of PGL(2,F_q),
                  returns another matrix representing the same element, with 
                  bottom row either [1 0] or [0 1].
                  
quarticLFTs()   : Given two separable polynomials of degree 3 or 4 over a finite
                  field K of odd characteristic, return the set of linear 
                  fractional transformations that take the ramification points 
                  of y^2 = f to those of y^2 = g.                      

quickj4()       : Given a quadruple [a,b,c,d] of elements of a field K, return
                  1/32 of the j-invariant of the Jacobian of the double cover of
                  P^1 ramified at those points.



================================================================================

VERSION HISTORY:

Version 2.00, 8 June 2025.

Completely rewritten. The old "sixpoints" functions have been replaced by the
"genustwo" functions. Also, if the functions are called with the "passback"
flag set to false, the memory usage of the programs will be bounded by O(q).

Updated mu_invariant so that it matches the definition in the paper. (The
previous versions of the function computed an affine shift of the function
defined in the paper.) Also modified so that one argument can be a linear
polynomial instead of a quadratic.

Removed some functions that produced PGL2 orbit representatives for degree-4
divisors of certain Galois types. All that is needed for our genus-2 algorithm
are Galois types (2,2) and (4). 



--------------------------------------------------------------------------------
Version 1.03, 20 December 2024.
Fixed a serious error in the function fourpoints31. The earlier version gave 
incorrect results when run on certain fields K containing cube roots of 1. The
error does not affect any of the computations involved in enumerating 
hyperelliptic curves of genus 2, because fourpoints31 is not used in any of 
these computations. It *does* affect the computations that enumerate
hyperelliptic curves of genus 3 using the programs in Hyperelliptic3.magma.

--------------------------------------------------------------------------------
Version 1.02, 11 March 2024.
Edited some comments.

--------------------------------------------------------------------------------
Version 1.01, 12 February 2024.
Revised comments in betaorbitreps() to refer to a result in the paper.

--------------------------------------------------------------------------------
Version 1.0, 25 January 2024.
First released version. Revision/cleanup/simplification of initial code.



================================================================================
*/


/*
==============================================================================
Forward definitions.
==============================================================================
*/

forward j_quartic;
forward mu_invariant;
forward nonsquare;
forward PGLreduce;
forward quarticLFTs;
forward quickj4;

/*
================================================================================
Utility functions.
================================================================================
*/


function automorphisms111111(aa,bb,cc)
  // Compute the elements of PGL_2 that stabilize the set {oo, 0, 1, aa, bb, cc}.

  K := Parent(aa+bb+cc);
  q := #K;
  
  I := Matrix(2,[K|1,0,0,1]);
  
  r := [0, 1, aa, bb, cc];

  // There are no nontrivial automorphisms if we have more than 8 distinct 
  // j-invariants among the 15 possible subsets of four elements of 
  // {oo, 0, 1, aa, bb, cc}. So check this first before doing more difficult 
  // computations.
  
  // Values that are reused in the computations:

  r12 := 1;
  r13 := aa^2;
  r14 := bb^2;
  r15 := cc^2;
  r23 := (aa-1)^2;
  r24 := (bb-1)^2;
  r25 := (cc-1)^2;
  r34 := (aa-bb)^2;
  r35 := (aa-cc)^2;
  r45 := (bb-cc)^2;
  
  // Compute the j-invariants of all 4-element subsets of {oo, 0, 1, aa, bb, cc}
  // that include oo.

  jset := { (r12 + r13 + r23)^3 / (r12*r13*r23),
            (r12 + r14 + r24)^3 / (r12*r14*r24),
            (r12 + r15 + r25)^3 / (r12*r15*r25),
            (r13 + r14 + r34)^3 / (r13*r14*r34),
            (r13 + r15 + r35)^3 / (r13*r15*r35),
            (r14 + r15 + r45)^3 / (r14*r15*r45),
            (r23 + r24 + r34)^3 / (r23*r24*r34),
            (r23 + r25 + r35)^3 / (r23*r25*r35),
            (r24 + r25 + r45)^3 / (r24*r25*r45),
            (r34 + r35 + r45)^3 / (r34*r35*r45)};
            
  // Start with these 10 j-invariants, then add more if we haven't aborted.

  if #jset gt 9 then return [I]; end if;

  jset join:= {quickj4([r[1],r[2],r[3],r[4]])};
  if #jset gt 9 then return [I]; end if;

  jset join:= {quickj4([r[1],r[2],r[3],r[5]])};
  if #jset gt 9 then return [I]; end if;

  jset join:= {quickj4([r[1],r[2],r[4],r[5]])};
  if #jset gt 9 then return [I]; end if;

  jset join:= {quickj4([r[1],r[3],r[4],r[5]])};
  if #jset gt 9 then return [I]; end if;

  jset join:= {quickj4([r[2],r[3],r[4],r[5]])};
  if #jset gt 9 then return [I]; end if;
  
  // We are still here. Now compute linear fractional transformations.

  lfts := [];
  
  rootsf := [ [a,1] : a in r ];
  rootsf cat:= [[1,0]]; 
  a, b, c, d, e, f := Explode(rootsf);

  for i,j,k in [1..6] do 
    if #{i,j,k} eq 3 then
      A := rootsf[i];
      B := rootsf[j];
      C := rootsf[k];
      // Find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
      M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                       b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                       c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
      BB := Basis(Nullspace(Transpose(M)))[1];
      r := BB[1];
      s := BB[2];
      t := BB[3];
      u := BB[4];
          
      imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
      imagee := [r*e[1] + s*e[2], t*e[1] + u*e[2]];
      imagef := [r*f[1] + s*f[2], t*f[1] + u*f[2]];
      if imaged[2] ne 0 then imaged := [imaged[1]/imaged[2],1]; else imaged := [K!1,0]; end if;
      if imagee[2] ne 0 then imagee := [imagee[1]/imagee[2],1]; else imagee := [K!1,0]; end if;
      if imagef[2] ne 0 then imagef := [imagef[1]/imagef[2],1]; else imagef := [K!1,0]; end if;
      if imaged in rootsf and imagee in rootsf and imagef in rootsf then lfts cat:= [[r,s,t,u]]; end if;
    end if;
  end for;
  
  // Put the automorphisms into standard form.
  
  return Sort([PGLreduce(Matrix(2,L)) : L in lfts]);

end function;
 

//------------------------------------------------------------------------------

function betaorbitreps(K,beta);
  // K is a finite field, beta is a pure imaginary element of a quadratic 
  // extension L of K. Let G be the subgroup of PGL(2,K) that fixes beta.
  // Compute orbit reps for the action of G on P^1(L). {beta} and {-beta} are
  // the two orbits of size less than #G; we do not return reps for these.
   
  // Lemma 5.2 from [Howe2025] shows that this algorithm is correct.

  q := #K;
  L := Parent(beta);
  gen := PrimitiveElement(L);
  return [beta*(1-gen^i)/(1+gen^i) : i in [0..q-2]];
end function;


//------------------------------------------------------------------------------

function cross(f)
  // Given an irreducible f, compute its cross polynomial, as defined 
  // in [Howe2025]. 
  K := BaseRing(Parent(f));
  q := #K;
  L := ext<K|Degree(f)>;
  S<y>:=PolynomialRing(L);  
  alpha1 := Roots(f,L)[1][1];
  alpha2 := alpha1^q;
  alpha3 := alpha2^q;
  alpha4 := alpha3^q;
  j := (alpha4-alpha2)*(alpha3-alpha1) / (alpha4-alpha1) / (alpha3-alpha2);
  return CharacteristicPolynomial(j,K);
end function;
 
//------------------------------------------------------------------------------


function curves_from_divisor(f,auts)
  // Given a separable polynomial of degree 2g+1 and 2g+2 over a finite field
  // K of odd characteristic, together with the set of elements of PGL(2,K)
  // that map its set of roots to itself, produce the one or two curves (and
  // automorphism groups) with these roots as Weierstrass points. 
  R := Parent(f);
  x := R.1;
  K := BaseRing(R);
  ns := nonsquare(K);
  
  degree := Degree(f);
  if 1 eq degree mod 2 then degree +:=1; end if;
  
  n := #auts;

  if n eq 1 then        
    // Could use "1 eq n mod 2" here, but Magma runs the code slightly faster 
    // with the more restrictive condition.
    curveauts := auts;
  else
    curveauts := [];
    for A in auts do
      num := A[1,1]*x + A[1,2];
      den := A[2,1]*x + A[2,2];
      g := Numerator(Evaluate(f,num/den)*den^degree);
      lead := Coefficient(g,Degree(g));
      if IsSquare(lead) then 
        curveauts cat:= [A];
      end if;
    end for;
  end if;
    
  if #curveauts eq n then
    // We have a nontrivial twist.
    return [<   f, 2*n, curveauts>, 
            <ns*f, 2*n, curveauts>];
  else
    return [<   f,   n, curveauts>];
  end if;

end function;

//------------------------------------------------------------------------------

function irreducible3(K);
  // Return an irreducible polynomial of degree 3 over K whose roots are
  // permuted by x --> 1/(1-x) and x --> (x-1)/x. If x^3 + s*x^2 - (s+3)*x + 1 
  // is irreducible, it is such a polynomial. 
  
  q := #K;
  pe := Factorization(q);
  p := pe[1][1];
  e := pe[1][2];
  if 0 ne e mod 3 then
    s := K!-1;
    repeat s +:= 1;
    until IsIrreducible(PolynomialRing(K)![1,-s-3,s,1]);
  else
    z := PrimitiveElement(K);
    s := 1/z;
    repeat s*:=z;
    until IsIrreducible(PolynomialRing(K)![1,-s-3,s,1]);
  end if;
  return PolynomialRing(K)![1,-s-3,s,1];
end function;

//------------------------------------------------------------------------------

function isomorphisms222(F,f: all:=true)
  // Given two sextic polynomials f and F over a finite field K, each of them
  // a product of three irreducible quadratics, return true or false depending 
  // on whether there is an element of PGL(2,K) taking one to the other.
  // If the flag "all" is true, also return a list of all such elements 
  // of PGL(2,K).
  // Note: This can be hastened by computing the mu-invariants of all quartic
  // divisors of f and F, and using those values to limit the possible maps.
  // For the inputs we plan to give this functions, those j-invariants will all
  // be equal, so we do not implement this improvement.
  
  f1, f2, f3 := Explode([a[1] : a in Factorization(f)]);
  F1, F2, F3 := Explode([a[1] : a in Factorization(F)]);
  assert 1 eq #{2,Degree(f1),Degree(F1),Degree(f2),Degree(F2),Degree(f3),Degree(F3)};
  
  R := Parent(f1);
  x := R.1;
  K := BaseRing(R);
  q := #K;
  L := ext<K|2>;
  
  a1,a2 := Explode([r[1] : r in Roots(f1,L)]);
  b1,b2 := Explode([r[1] : r in Roots(f2,L)]);
  c1,c2 := Explode([r[1] : r in Roots(f3,L)]);
  
  A1,A2 := Explode([r[1] : r in Roots(F1,L)]);
  B1,B2 := Explode([r[1] : r in Roots(F2,L)]);
  C1,C2 := Explode([r[1] : r in Roots(F3,L)]);
  
  targets := {A1,A2,B1,B2,C1,C2};
  
  m := Matrix(2,[a1*(b1-a2), a2*(a1-b1), (b1-a2), (a1-b1)]);
  // Takes oo to a1, 0 to a2, 1 to b1.
  minv := m^-1;
  
  homs := [];
  
  for triple in [ [A1,A2,B1], [A1,A2,B2], [A1,A2,C1], [A1,A2,C2],
                  [A2,A1,B1], [A2,A1,B2], [A2,A1,C1], [A2,A1,C2],
                  [B1,B2,A1], [B1,B2,A2], [B1,B2,C1], [B1,B2,C2],
                  [B2,B1,A1], [B2,B1,A2], [B2,B1,C1], [B2,B1,C2],
                  [C1,C2,A1], [C1,C2,A2], [C1,C2,B1], [C1,C2,B2],
                  [C2,C1,A1], [C2,C1,A2], [C2,C1,B1], [C2,C1,B2]] do
    t1, t2, t3 := Explode(triple);
    M := Matrix(2,[t1*(t3-t2), t2*(t1-t3), (t3-t2), (t1-t3)]);
    possible := M*minv;
    good := true;
    for s in [b2,c1,c2] do
      num := possible[1,1]*s + possible[1,2];
      den := possible[2,1]*s + possible[2,2];
      if den eq 0 or not num/den in targets then
        good := false;
        break s;
      end if;
      if s eq b2 and num/den ne t3^q then
        good := false;
        break s;
      end if;
    end for;
    if good then
      scalar := possible[2,1];
      if scalar eq 0 then scalar := possible[2,2]; end if;
      possible := possible/scalar;
      possible := Matrix(2,[K|a : a in Eltseq(possible)]);
      if &and[p in K : p in Eltseq(possible)] then
        if not all then return true,_; end if;
        homs cat:= [possible];
      end if;
    end if;
  end for;
  
  if #homs eq 0 then return false, _; end if;
  return true, homs;
end function;

    
//------------------------------------------------------------------------------

function IsFrobeniusFunction(F,f)
  // The Frobenius function of an irreducible polynomial f of degree at least 3
  // is defined in [Howe2024]. This function tests whether F is the Frobenius 
  // function for such an f.
  
  n := Degree(f);
  assert IsOdd(n) and n ge 3;
  assert IsIrreducible(f);
  r := (n-1)/2;
  
  if not (Degree(Numerator(F)) le r and Degree(Denominator(F)) le r)
    then return false;
  end if;
  
  R := Parent(f);
  K := BaseRing(R);
  q := #K;
  L<alpha>:=ext<K | f>;

  return alpha^q eq Evaluate(F,alpha);
end function;


//------------------------------------------------------------------------------

function j_quartic(g)
  // Given a cubic or quartic polynomial g, compute the j-invariant of the 
  // Jacobian of y^2 = g.
  
  denom := Discriminant(g);
  if Degree(g) eq 3 then 
    denom *:= Coefficient(g,3)^2;
  end if;
  return 256*(Coefficient(g,2)^2 + 12*Coefficient(g,0)*Coefficient(g,4)
             - 3*Coefficient(g,3)*Coefficient(g,1))^3 / denom;
end function;

//------------------------------------------------------------------------------

function mapsbetweenpairsofquadratics(pair1,pair2)
  // pair1 and pair2 are each pairs of distinct irreducible quadratics over a
  // finite field K of odd characteristic.
  // Return the (possibly empty) set of elements of PGL2 that take the
  // first pair to the second.
  
  if mu_invariant(pair1[1],pair1[2]) ne mu_invariant(pair2[1],pair2[2]) then
    return [];
  end if;

  f1, f2 := Explode(pair1);
  g1, g2 := Explode(pair2);

  R := Parent(f1+g1);
  K := BaseRing(R);
  x := R.1;
  L := ext<K|2>;
  q := #K;
  a1 := Roots(f1,L)[1][1]; a2 := a1^q;
  a3 := Roots(f2,L)[1][1]; a4 := a3^q;
  b1 := Roots(g1,L)[1][1]; b2 := b1^q;
  b3 := Roots(g2,L)[1][1]; b4 := b3^q;

  M1 := Matrix(2,[a1*(a3-a2), a2*(a1-a3), (a3-a2), (a1-a3)]);
  // M1 sends oo to a1, 0 to a2, and 1 to a3.
  // So M1^-1 sends a1 to oo, a2 to 0, and a3 to 1.
  
  list := [];
  
  for cs in [[b1,b2,b3,b4],[b1,b2,b4,b3],[b2,b1,b3,b4],[b2,b1,b4,b3],
             [b3,b4,b1,b2],[b4,b3,b1,b2],[b3,b4,b2,b1],[b4,b3,b2,b1]] do
    c1, c2, c3, c4 := Explode(cs);
    M2 := Matrix(2,[c1*(c3-c2), c2*(c1-c3), (c3-c2), (c1-c3)]);
    // M2 sends oo to c1, 0 to c2, and 1 to c3.
    M := M2*M1^-1;
    if M[2,1] ne 0 then M := M/M[2,1]; else M := M/M[2,2]; end if;
    eltsM := Eltseq(M);
    if &and[m^q eq m : m in eltsM] then
      list cat:= [Matrix(2,[K|m : m in eltsM])];
    end if;
  end for;
  return list;
end function;


//------------------------------------------------------------------------------

function mu_invariant(q1, q2)
  // q1 is (x^2 + a*x + b) and q2 is (x^2 + c*x + d).
  // return mu := (a*c - 2*b - 2*d)^2/((a^2 - 4*b)*(c^2 - 4*d)).
  // This is an invariant of the product of two irreducible quadratics
  // and j_quartic(q1*q2) = 64*(mu + 3)^3/(mu - 1)^2.
  // See [Howe2025], Remark 3.5.
  if Degree(q1) eq 2 and Degree(q2) eq 2 then
    b,a,one := Explode(Coefficients(q1));
    d,c,one := Explode(Coefficients(q2));
    return (a*c - 2*b - 2*d)^2/((a^2 - 4*b)*(c^2 - 4*d));
  end if;
    
  if Degree(q1) eq 2 then
    b,a,one := Explode(Coefficients(q1));
    c,one := Explode(Coefficients(q2));
  else    
    b,a,one := Explode(Coefficients(q2));
    c,one := Explode(Coefficients(q1));
  end if;
  return (a-2*c)^2/(a^2-4*b);

end function;

//------------------------------------------------------------------------------  

function nonsquare(K)
  // Given a finite field of odd characteristic, return a nonsquare in K.
  // When possible (K is an odd-degree extension of the prime field) we choose
  // a nonsquare in the prime field. 
  // When possible (K is an odd-degree extension of a prime field of order 
  // congruent to 3 mod 4) we choose -1.

  p,e := Explode(Factorization(#K)[1]);
  if IsOdd(e) then
    n := K!-2;
    repeat n +:= 1;
    until not IsSquare(n);
  else
    n := PrimitiveElement(K);
  end if;
  assert not IsSquare(n);
  return n;
end function;

//------------------------------------------------------------------------------

function PGLreduce(M)
  // Given a matrix in GL(2,K), return its standard form in PGL(2,K), i.e. the 
  // form where either the lower left entry is 1, or the lower left entry is 0
  // and the lower right is 1.
  s := M[2,1];
  if s eq 0 then s := M[2,2]; end if;
  return M/s;
end function;

//------------------------------------------------------------------------------


function quarticLFTs(f,g)
  // Given two separable polynomials of degree 3 or 4, 
  // return the set of linear fractional transformations that take the
  // ramification points of y^2 = f to those of y^2 = g.
  // LFTs are given as a sequence of four elements [a,b,c,d] with either 
  // (c = 0 and d = 1) or c = 1.

  K := BaseRing(Parent(f));
  q := #K;
  R := Parent(f);
  x := R.1;
  
  degreesf := [Degree(a[1]) : a in Factorization(f)];
  if Degree(f) eq 3 then degreesf cat:= [1]; end if;
  Sort(~degreesf);
  degreesg := [Degree(a[1]) : a in Factorization(g)];
  if Degree(g) eq 3 then degreesg cat:= [1]; end if;
  Sort(~degreesg);
  if degreesf ne degreesg then return []; end if;

  lfts := [];
  
  case degreesf:
    when [1,1,1,1]:
      rootsf := [ [a[1],1] : a in Roots(f) ];
      if #rootsf eq 3 then rootsf cat:= [[1,0]]; end if;
      rootsg := [ [a[1],1] : a in Roots(g) ];
      if #rootsg eq 3 then rootsg cat:= [[1,0]]; end if;
      a := rootsf[1];
      b := rootsf[2];
      c := rootsf[3];
      d := rootsf[4];
      for i,j,k,l in [1..4] do 
        if #{i,j,k,l} eq 4 then
          A := rootsg[i];
          B := rootsg[j];
          C := rootsg[k];
          D := rootsg[l];
          // find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
          M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                           b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                           c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
          B := Basis(Nullspace(Transpose(M)))[1];
          r := B[1];
          s := B[2];
          t := B[3];
          u := B[4];
          
          imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
          if D[1]*imaged[2] eq D[2]*imaged[1] then lfts cat:= [[r,s,t,u]]; end if;
        end if;
      end for;
  
    when [1,1,2]:
      L := ext<K|2>;
      rootsf := [ [a[1],1] : a in Roots(f,L) | a[1] in K];
      rootsf cat:= [ [a[1],1] : a in Roots(f,L) | not a[1] in K];
      if #rootsf eq 3 then rootsf := [[L!1,0]] cat rootsf; end if;
      rootsg := [ [a[1],1] : a in Roots(g,L) | a[1] in K];
      rootsg cat:= [ [a[1],1] : a in Roots(g,L) | not a[1] in K];
      if #rootsg eq 3 then rootsg := [[L!1,0]] cat rootsg; end if;
      a := rootsf[3];
      b := rootsf[4];
      c := rootsf[1];
      d := rootsf[2];
      for i,j in [3..4], k,l in [1..2] do 
        if #{i,j,k,l} eq 4 then
          A := rootsg[i];
          B := rootsg[j];
          C := rootsg[k];
          D := rootsg[l];
          // find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
          M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                           b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                           c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
          B := Basis(Nullspace(Transpose(M)))[1];
          r := B[1];
          s := B[2];
          t := B[3];
          u := B[4];
          
          imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
          if D[1]*imaged[2] eq D[2]*imaged[1] then lfts cat:= [[r,s,t,u]]; end if;
        end if;
      end for;


     when [2,2]:
      L := ext<K|2>;
      f1 := Factorization(f)[1][1];
      f2 := f div f1;
      a := [Roots(f1,L)[1][1],1];
      b := [z^q : z in a];
      c := [Roots(f2,L)[1][1],1];
      d := [z^q : z in c];
      g1 := Factorization(g)[1][1];
      g2 := g div g1;
      A := [Roots(g1,L)[1][1],1];
      B := [z^q : z in A];
      C := [Roots(g2,L)[1][1],1];
      D := [z^q : z in C];
      
      rootsg := [A,B,C,D];

      for i,j,k,l in [1..4] do
        if #{i,j,k,l} eq 4 and (i-j)^2 eq 1 and (k-l)^2 eq 1 then
          A := rootsg[i];
          B := rootsg[j];
          C := rootsg[k];
          D := rootsg[l];
          // find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
          M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                           b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                           c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
          B := Basis(Nullspace(Transpose(M)))[1];
          r := B[1];
          s := B[2];
          t := B[3];
          u := B[4];
          
          imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
          if D[1]*imaged[2] eq D[2]*imaged[1] then lfts cat:= [[r,s,t,u]]; end if;
        end if;
      end for;
          
    when [1,3]:
      L := ext<K|3>;
      if Degree(f) eq 3 then 
        d := [K!1,0]; 
        f2 := f; 
      else 
        d := [Roots(f)[1][1],1];
        f2 := f div (x-d[1]);
      end if;
      a := [Roots(f2,L)[1][1],1];
      b := [z^q : z in a];
      c := [z^q : z in b];

      if Degree(g) eq 3 then 
        D := [K!1,0]; 
        g2 := g; 
      else 
        D := [Roots(g)[1][1],1];
        g2 := g div (x-D[1]);
      end if;
      A := [Roots(g2,L)[1][1],1];
      B := [z^q : z in A];
      C := [z^q : z in B];

      rootsg := [A,B,C,D];

      for i in [1..3] do
        A := rootsg[i];
        B := [z^q : z in A];
        C := [z^q : z in B];
        
        // find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
        M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                         b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                         c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
        B := Basis(Nullspace(Transpose(M)))[1];
        r := B[1];
        s := B[2];
        t := B[3];
        u := B[4];
          
        imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
        if D[1]*imaged[2] eq D[2]*imaged[1] then lfts cat:= [[r,s,t,u]]; end if;
      end for;

    when [4]:
      L := ext<K|4>;
      a := [Roots(f,L)[1][1],1];
      b := [z^q : z in a];
      c := [z^q : z in b];
      d := [z^q : z in c];

      A := [Roots(g,L)[1][1],1];
      B := [z^q : z in A];
      C := [z^q : z in B];
      D := [z^q : z in C];

      rootsg := [A,B,C,D];

      for i in [1..4] do
        A := rootsg[i];
        B := [z^q : z in A];
        C := [z^q : z in B];
        D := [z^q : z in C];
        
        // find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
        M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                         b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                         c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
        B := Basis(Nullspace(Transpose(M)))[1];
        r := B[1];
        s := B[2];
        t := B[3];
        u := B[4];
          
        imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
        if D[1]*imaged[2] eq D[2]*imaged[1] then lfts cat:= [[r,s,t,u]]; end if;
      end for;
  end case;

  standardLFTs := [];
  for z in lfts do
    if z[3] ne 0 then
      standardLFTs cat:= [ [K!(z[1]/z[3]), K!(z[2]/z[3]), K!1, K!(z[4]/z[3])] ];
    else
      standardLFTs cat:= [ [K!(z[1]/z[4]), K!(z[2]/z[4]), K!0, K!1] ];
    end if;
  end for;
  standardLFTs := Sort([a : a in Set(standardLFTs)]);
  return [Matrix(2,s) : s in standardLFTs];
end function;


//------------------------------------------------------------------------------

function quickj4(quadruple)
  // Given a quadruple [a,b,c,d], compute 1/32 of the j-invariants of the 
  // genus-1 curve y^2 = (x-a)*(x-b)*(x-c)*(x-d)
  a,b,c,d := Explode(quadruple);
  ab:=(a-b)^2;
  ac:=(a-c)^2;
  ad:=(a-d)^2;
  bc:=(b-c)^2;
  bd:=(b-d)^2;
  cd:=(c-d)^2;
  return  (ab*cd + ac*bd + ad*bc)^3/(ab*ac*ad*bc*bd*cd); 
end function;


/*
================================================================================
Functions for producing orbit representatives for certain Galois types in Sym^4. 
================================================================================
*/

function fourpoints1111(K)
  // Given a finite field K of odd characteristic, find representatives for
  // the PGL(2,K) orbits of sets of four distinct elements of P^1(K).
  // We represent such sets by monic separable polynomials of degree 3 or 4
  // that factor as a product of distinct linears.
  
  // We normalize what the three fixed-point-free involutions of the set are by
  // conjugating. If the fixed points of any of these involutions are rational,
  // we normalize that involution to be x --> -x.
  // Note that the fixed points are rational if and only if the
  // negative determinant of the involution is a square.
  // So if none of the involutions has rational fixed points, then -1 is not a 
  // square, and all involutions have square determinants.
  
  // Note that there are (q+1) choose 4 sets of four distinct elements of P^1,
  // and we are dividing out by PGL(2,K). That means that the sum, over our
  // representatives, of 1 over the automorphism group of the representative
  // should be equal to (q-2)/24.
  
  q := #K;
  p,e := Explode(Factorization(q)[1]);
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);

  list := [];
  taken := [];
  I := Matrix(2,[K|1,0,0,1]);
  
  // Case 1: There is an involution with rational fixed points.
  // Normalize it to x --> -x.
  // If -1 is a square, then we get two cases:
  // Second is x --> d/x and third is x --> -d/x, where d is a 1 or a nonsquare.
  // If -1 is not a square, we get one case:
  // Second is x --> 1/x and third is x --> -1/x.

  // Case 2: No involution has a rational fixed point. In this case -1 is not
  // a square, and we normalize first to be x --> -1/x.
  // Second is then [a 1 1 -a] for some a with -1-a^2 equal to a square.
  // Third is [-1/a 1 1 1/a]
  

  if IsSquare(K!-1) then
    // There is an involution with rational fixed points.
    inv1 := Matrix(2,[-1,0,0,1]);
    
    // First case: They *all* have rational fixed points.
    inv2 := Matrix(2,[0, 1,1,0]);
    inv3 := Matrix(2,[0,-1,1,0]);
    auts := [I,inv1,inv2,inv3];
    
    i := Sqrt(K!-1);
    
    // Orbits of size two: {oo,0} {1,-1}
    for a in K do
      if not a in {K|0,1,-1,i,-i} then
        four := (x-a)*(x+a)*(x-1/a)*(x+1/a);
        j := j_quartic(four);
        if not j in taken then
          taken cat:= [j];
          if j in {K|0,1728} then
            bigauts := quarticLFTs(four,four);
            list cat:= [<four,#bigauts,bigauts>];
          else          
            list cat:= [<four,#auts,auts>];
          end if;
        end if;
      end if;
    end for;
    
    // Second case: The other two *do not* have rational fixed points.
    inv2 := Matrix(2,[0, ns,1,0]);
    inv3 := Matrix(2,[0,-ns,1,0]);
    auts := [I,inv1,inv2,inv3];

    // Orbits of size two: {oo,0}
    for a in K do
      if not a in {K|0} then
        four := (x-a)*(x+a)*(x-ns/a)*(x+ns/a);
        j := j_quartic(four);
        if not j in taken then
          taken cat:= [j];
          if j in {K|0,1728} then
            bigauts := quarticLFTs(four,four);
            list cat:= [<four,#bigauts,bigauts>];
          else          
            list cat:= [<four,#auts,auts>];
          end if;
        end if;
      end if;
    end for;

  else
    // -1 is not a square.
    
    // First case: There is an involution with rational fixed points.
    // In this case, there are two such, which we normalize to 
    // x --> -x and x --> 1/x.

    inv1 := Matrix(2,[K|-1,0,0,1]);
    inv2 := Matrix(2,[K|0, 1,1,0]);
    inv3 := Matrix(2,[K|0,-1,1,0]);
    auts := [I,inv1,inv2,inv3];

    // Orbits of size two: {oo,0} {1,-1}
    for a in K do
      if not a in {K|0,1,-1} then 
        four := (x-a)*(x+a)*(x-1/a)*(x+1/a);
        j := j_quartic(four);
        if not j in taken then
          taken cat:= [j];
          if j in {K|0,1728} then
            bigauts := quarticLFTs(four,four);
            list cat:= [<four,#bigauts,bigauts>];
          else          
            list cat:= [<four,#auts,auts>];
          end if;
        end if;
      end if;
    end for;
    
    
    // Second case: No involution has rational fixed points.
    inv1 := Matrix(2,[K|0,-1,1,0]);
    good := 0;
    for a in PrimeField(K) do
      if IsSquare(-1-a^2) then good := a; break a; end if;
    end for;
    if good eq 0 then
      for a in K do
        if IsSquare(-1-a^2) then good := a; break a; end if;
      end for;
    end if;
    inv2 := Matrix(2,[good,1,1,-good]);
    inv3 := Matrix(2,[-1/good,1,1,1/good]);
    auts := [I,inv1,inv2,inv3];

    // a, -1/a, (good*a + 1)/(a - good), (-a + good)/(good*a + 1)
    // No orbits of size two.
    // Orbit of oo: oo, 0, good, -1/good

    four := x*(x-good)*(x+1/good);
    j := j_quartic(four);
    if not j in taken then
      taken cat:= [j];
      if j in {K|0,1728} then
        bigauts := quarticLFTs(four,four);
        list cat:= [<four,#bigauts,bigauts>];
      else          
        list cat:= [<four,#auts,auts>];
      end if;
    end if;


    for a in K do
      if not a in {0,good,-1/good} then
        four := (x-a)*(x+1/a)*(x-(good*a+1)/(a-good))*(x-(-a+good)/(good*a+1));
        j := j_quartic(four);
        if not j in taken then
          taken cat:= [j];
          if j in {K|0,1728} then
            bigauts := quarticLFTs(four,four);
            list cat:= [<four,#bigauts,bigauts>];
          else          
            list cat:= [<four,#auts,auts>];
          end if;
        end if;
      end if;
    end for;
  end if;
  
  assert &+[1/r[2] : r in list] eq (q-2)/24;
  
  return list;
end function;

//------------------------------------------------------------------------------

function fourpoints22(K)
  // Given a finite field K of odd characteristic, find representatives for the 
  // PGL(2,K) orbits of sets of two pairs of conjugate quadratic points of P^1.
  // We represent such sets by monic separable polynomials of degree 4 that
  // factor as a product of two distinct quadratics. We return the quartics,
  // the sizes of their automorphism groups, and the automorphism groups
  // themselves.
  // We use Theorem 3.4 of [Howe2025]. However, that result gives us
  // representatives whose automorphism groups (isomorphic to the Klein 4-group
  // with one exception) are not normalized, so we go through the list 
  // produces by the theorem and modify the representative so that the
  // PGL(2,K) stabilizer of the quartic is one of three fixed groups (except
  // for the single exceptional case).
  
  q := #K;
  R<x>:=PolynomialRing(K);
  polys22 := [];
  
  ns := nonsquare(K);
  L<rho>:=ext<K | x^2 - ns>;
  
  zeta := PrimitiveElement(L);
  zetai:=L!1;
  
  I := Matrix(2,[K|1,0,0,1]);
  
  // We use Theorem 3.4 from the paper. Our representative polynomials
  // will be (x^2 - ns)*f, where f ranges over the minimal polynomials of
  // rho*(zeta^i-1)/(zeta^i+1), for i = 1 to i = (q-1)/2. For i < (q-1)/2,
  // the automorphism group of the polynomial has order 4; for i = (q-1)/2,
  // it has order 8. The groups are as given in the code below.
  
  // We do the cases with automorphism group of order 4 first.
  
  for i in [1..(q-3) div 2] do
    zetai *:= zeta;
    f := MinimalPolynomial(rho*(zetai-1)/(zetai+1));
    A := Coefficient(f,1);
    B := Coefficient(f,0);

    inv1 := PGLreduce(Matrix(2,[-B-ns,-A*ns,A,B+ns]));

    twov := Sqrt((A^2-4*B)/ns);
    inv2 := PGLreduce(Matrix(2,[-A, -2*B-ns*twov, 2-twov, A]));
    inv3 := PGLreduce(Matrix(2,[-A, -2*B+ns*twov, 2+twov, A]));
    
    polys22 cat:= [<(x^2-ns)*f, 4, [I,inv1,inv2,inv3]>];
  end for;
  
  // And finally, i = (q-1)/2.
  
  zetai *:= zeta;
  f := MinimalPolynomial(rho*(zetai-1)/(zetai+1));
  A := Coefficient(f,1);
  B := Coefficient(f,0);
  assert B eq ns;
  
  inv1 := Matrix(2,[-B-ns,-A*ns,A,B+ns]);

  twov := Sqrt((A^2-4*B)/ns);
  inv2 := Matrix(2,[-A, -2*B-ns*twov, 2-twov, A]);
  inv3 := Matrix(2,[-A, -2*B+ns*twov, 2+twov, A]);
  
  iota := Matrix(2,[-A/2,-ns,1,A/2]);
  polys22 cat:= [<(x^2-ns)*f, 8, [I,inv1,inv2,inv3] cat 
                                 [PGLreduce(iota*m) : m in [I,inv1,inv2,inv3]]  >];


  // Now we renormalize these products so that the automorphism groups are in a
  // standard form. We only do this for the products with automorphism groups of
  // order 4, because there is only one product with larger automorphism group.
  
  // When q is 3 mod 4 we will want to know an element of K, call it "standard",
  // with -1 - standard^2 equal to a square.
  
  if 3 eq #K mod 4 then
    standard := K!0;
    repeat standard +:= 1;
    until IsSquare(-1-standard^2);
  else
    standard := 0;
  end if;
  
  costandard := Sqrt(-1-standard^2);
  // standard^2 + costandard^2 = -1
  
  for i in [1..#polys22] do
    product := polys22[i][1];
    autos := polys22[i][3];
    if #autos eq 4 then
      nontrivialautos := [A : A in autos | not (A[1,1] eq A[2,2] and A[2,1] eq 0 and A[1,2] eq 0)];
      splitfixedpoints := [IsSquare(-Determinant(A)) : A in nontrivialautos];
      ParallelSort(~splitfixedpoints,~nontrivialautos);
    
      // We will normalize on the third and second involutions.
    
      A3 := nontrivialautos[3];
      A2 := nontrivialautos[2];
      if splitfixedpoints[3] then
        fixedpol3 := x^2*A3[2,1] + x*A3[2,2] - x*A3[1,1] - A3[1,2];
        if Degree(fixedpol3) eq 2 then
          root1, root2 := Explode([a[1] : a in Roots(fixedpol3)]);
          M3 := Matrix(2,[1,-root1,1,-root2]);
        else // Degree is 1, and A3 is [-1, a; 0, 1].
          root1 := Roots(fixedpol3)[1][1];
          M3 := Matrix(2,[1,-root1,0,1]);
        end if;          

        A2 := M3*A2*M3^-1;
        
        // Now A2 must be of the form x --> s/x.
        scale := A2[1,2]/A2[2,1];
        bool, root := IsSquare(scale);
        if not bool then 
          bool, root := IsSquare(scale/ns);
        end if;
        M2 := Matrix(2,[1,0,0,root]);
        
        M := M2*M3;
        // So M*A*M^-1 will conjugate the existing automorphisms into 
        // standardized ones.
        // What does it do to our product of quadratics?
        
        newproduct := Numerator(Evaluate(product,
                                 (M[2,2]*x - M[1,2])/(-M[2,1]*x + M[1,1]))
                                 * (-M[2,1]*x + M[1,1])^4);
        newproduct := newproduct / Coefficient(newproduct,4);
        
        polys22[i] := <newproduct, 4, [PGLreduce(M*A*M^-1) : A in autos]>;
      else
      
        // None of our involutions have a fixed point. Necessarily, -1 is a 
        // nonsquare, and the function nonsquare() chooses this for out ns.
        // Note that this also implies that q is an odd power of a prime that
        // is 3 modulo 4.
      
        // We have two commuting involutions, each with nonrational fixed
        // points. Move the fixed points of A3 to the roots of x^2 + 1.
        
        fixedpol3 := x^2*A3[2,1] + x*A3[2,2] - x*A3[1,1] - A3[1,2];
        fixedpol3 := fixedpol3/A3[2,1];
        shift := -Coefficient(fixedpol3,1)/2;
        scale := 1/Sqrt(-Coefficient(fixedpol3,1)^2/4+Coefficient(fixedpol3,0));
        M3 := Matrix(2,[scale, -shift*scale,0,1]);        
        A2 := PGLreduce(M3*A2*M3^-1);

        // A3 is now  x --> -1/x
        // A2 is an involution without rational fixed points 
        // that commutes with A3.
        // Involutions that commute with A3:
        // [0, 1; 1, 0] --- has rational fixed points.
        // [0,-1; 1, 0] --- same as A3.
        // [a, 1; 1,-a] --- nonrational fixed points when a^2 + 1 is nonsquare.
        // A2 = [a, 1; 1, -a] 
        // We want to transform A2 into [standard, 1; 1, -standard];
        
        a := A2[1,1];
        r := (a*standard - 1) + costandard*Sqrt(-(a^2 + 1));
        s := a + standard;
        
        M2 := Matrix(2,[r,s,s,-r]);
        
        check := PGLreduce(M2*A2*M2^-1);
        assert check eq Matrix(2,[standard,1,1,-standard]);

        M := M2*M3;
        // So M*A*M^-1 will conjugate the existing automorphisms into 
        // standardized ones.
        // What does it do to our product of quadratics?
        
        newproduct := Numerator(Evaluate(product,
                                 (M[2,2]*x - M[1,2])/(-M[2,1]*x + M[1,1]))
                                 * (-M[2,1]*x + M[1,1])^4);
        newproduct := newproduct / Coefficient(newproduct,4);
        
        polys22[i] := <newproduct, 4, [PGLreduce(M*A*M^-1) : A in autos]>;
      end if;
    end if;
  end for;

  return polys22;
end function;  


//------------------------------------------------------------------------------

function fourpoints4(K : ns := 0)
  // Given a finite field K of odd characteristic, find representatives for
  // the PGL(2,K) orbits of sets of four conjugate elements of P^1. We represent
  // such sets by monic irreducible polynomials of degree 4. We implement this 
  // using Theorem 1.2 of [Howe2025], but we arrange to do nearly all 
  // computations done in K rather than in extensions fields. Note that the
  // representatives have the property that their involution is normalized to
  // be either x --> 1/x or x --> ns/x.
  // The optional input ns should be a nonsquare in K.
  
  q := #K;
  R<x>:=PolynomialRing(K);
  L := ext<K|2>;
  S<y>:=PolynomialRing(L);
  gen := PrimitiveElement(L);
  ns := K!ns; 
  if IsSquare(ns) then 
    ns := nonsquare(K);
  end if;
  beta := Roots(y^2-ns)[1][1];

  // Keep track of trace of gen^i, of trace of gen^i/beta, of norm of gen^i.

  n0 := Norm(gen,K);
  t0 := Trace(gen,K);
  tbeta0 := Trace(gen/beta,K);
  
  list := [];

  oldt := t0/n0;
  oldtbeta := -tbeta0/n0;

  t := t0;
  tbeta := tbeta0;
  n := n0;
  
  // Recursion coefficients
  r1 := t0^2-2*n0;
  r2 := -n0^2;
  
  upperlimit := Floor(q/4);
  
  I := Matrix(2,[K!1,0,0,1]);
  inv1 := Matrix(2,[K!0,1,1,0]);
  inv2 := Matrix(2,[K!0,ns,1,0]);
  
  for i in [1..upperlimit] do
    c3 := (4*n - 4)/(t - n - 1);
    c2 := (-2*t - 6*n - 6)/(t - n - 1);
    list cat:= [<x^4 + c3*x^3 + c2*x^2 + c3*x + 1, 2, [I,inv1]>];
    den := n - t + 1;
    c3 := 4*tbeta*ns/den;
    c2 := -2*ns*(n + 3*t + 1)/den;
    list cat:= [<x^4 + c3*x^3 + c2*x^2 + ns*c3*x + ns^2, 2, [I,inv2]>];
    
    // Update values of traces and norm
    newt := r1*t + r2*oldt;
    oldt := t;
    t := newt;
    
    newtbeta := r1*tbeta + r2*oldtbeta;
    oldtbeta := tbeta;
    tbeta := newtbeta;
    
    n *:= n0^2;
  end for;
  
  // Now for the final ones. 
  // If q = 1 mod 4 there is one more, of first type, and it has j = 1728.
  // If q = 3 mod 4 there are two more, of both types, and the second type has j = 1728.
  
  M := ext<K|4>;
  
  case q mod 4:
    when 1:
      c3 := (4*n - 4)/(t - n - 1);
      c2 := (-2*t - 6*n - 6)/(t - n - 1);
      h := x^4 + c3*x^3 + c2*x^2 + c3*x + 1;
      alpha1 := Roots(h,M)[1][1];
      alpha2 := alpha1^q;
      alpha3 := alpha2^q;
      alpha4 := alpha3^q;
      // want element of PGL(2,M) that takes alpha1, alpha2, alpha3 to
      // alpha2, alpha3, alpha4
      M1 := Matrix(2,[alpha1*(alpha3-alpha2), alpha2*(alpha1-alpha3), (alpha3-alpha2), (alpha1-alpha3)]);
      M2 := Matrix(2,[alpha2*(alpha4-alpha3), alpha3*(alpha2-alpha4), (alpha4-alpha3), (alpha2-alpha4)]);
      M3 := M2*M1^-1;
      aut := Matrix(2,[K|M3[1,1]/M3[2,1], M3[1,2]/M3[2,1], 1, M3[2,2]/M3[2,1]]);
      list cat:= [<h, 4, [I,PGLreduce(aut),PGLreduce(aut^2),PGLreduce(aut^3)]>];
    when 3:
      c3 := (4*n - 4)/(t - n - 1);
      c2 := (-2*t - 6*n - 6)/(t - n - 1);
      list cat:= [<x^4 + c3*x^3 + c2*x^2 + c3*x + 1, 2, [I,inv1]>];
    
      den := n - t + 1;
      c3 := 4*tbeta*ns/den;
      c2 := -2*ns*(n + 3*t + 1)/den;
      h := x^4 + c3*x^3 + c2*x^2 + ns*c3*x + ns^2;
      alpha1 := Roots(h,M)[1][1];
      alpha2 := alpha1^q;
      alpha3 := alpha2^q;
      alpha4 := alpha3^q;
      // want element of PGL(2,M) that takes alpha1, alpha2, alpha3 to
      // alpha2, alpha3, alpha4
      M1 := Matrix(2,[alpha1*(alpha3-alpha2), alpha2*(alpha1-alpha3), (alpha3-alpha2), (alpha1-alpha3)]);
      M2 := Matrix(2,[alpha2*(alpha4-alpha3), alpha3*(alpha2-alpha4), (alpha4-alpha3), (alpha2-alpha4)]);
      M3 := M2*M1^-1;
      aut := Matrix(2,[K|M3[1,1]/M3[2,1], M3[1,2]/M3[2,1], 1, M3[2,2]/M3[2,1]]);
      list cat:= [<h, 4, [I,PGLreduce(aut),PGLreduce(aut^2),PGLreduce(aut^3)]>];
  end case;

  return list;
end function;


/*
================================================================================
Functions for producing orbit representatives for Sym^6.
================================================================================
*/

function genustwo1x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (1,1,1,1,1,1), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (1,1,1,1,1,1),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives, of 1 over the size of the
  // automorphism group of the representative should be (q-2)*(q-3)*(q-4)/720.
  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  // We normalize our collection of six points by assuming one is at oo, one
  // is at 0, and the sum of the others is 1. Every collection of six rational
  // points in P^1 can be put in such a form in at least one way, with one
  // exception: when the six points are the six elements of P^1(F_5). We handle
  // that case separately.
  
  // [Proof sketch: If there is a sextuple that does not have a representative
  // of this form, write it as oo, 0, 1, x, y, -1-x-y. Shifting by 1 gives the
  // sextuple oo, -1, 0, x-1, y-1, -2-x-y, and we see that 5 = 0, so we are in
  // characteristic 5. Then, applying the condition to all equivalent sextuples
  // that include 0 and oo, we get an easily-solvable system of 5 equations in
  // x and y.]
  
  // To choose which of these normalized forms to use, we use the one where the
  // ordered set of points other than 0 and oo comes first in some total 
  // ordering.
  
  q := #K;
  if q lt 5 then return []; end if;
  
  Clist := [];
  checksum := 0;
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;
  
  sortKstar := Sort([a : a in K | a ne 0]);
  R<x>:=PolynomialRing(K);
  I := Matrix(2,[K|1,0,0,1]);
  
  for i1 in [1..q-4] do
    a1 := sortKstar[i1];
    for i2 in [i1+1..q-3] do
      a2 := sortKstar[i2];
      for i3 in [i2+1..q-2] do
        a3 := sortKstar[i3];
        a4 := 1 - a1 - a2 - a3;
        if a3 ge a4 then continue i3; end if;
            
        auts := false;
            
        basecase := Sort([a1,a2,a3,a4]);
            
        for i in [1..4] do
          if 1 ne 5*basecase[i] then
            s := 1/(1-5*basecase[i]);
            newcase := Sort([-basecase[i]*s] cat [(basecase[j]-basecase[i])*s : j in [1..4] | j ne i]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
        end for;
            
        // Put 0 at oo.
           
        newbase := [1/basecase[i] : i in [1..4]];

        sum := &+newbase;
        if sum ne 0 then
          s := 1/sum;
          newcase := Sort([a*s : a in newbase]);
          if newcase lt basecase then continue i3; end if;
          if newcase eq basecase then auts:= true; end if;
        end if;
              
        for j in [1..4] do
          if sum ne 5*newbase[j] then
            s := 1/(sum-5*newbase[j]);
            newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..4] | k ne j]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
        end for;

        for i in [1..4] do
          // send ai to oo and oo to 0... x --> 1/(x-ai)
          newbase := [-1/basecase[i]] cat [1/(basecase[j]-basecase[i]) : j in [1..4] | j ne i];
          
          sum := &+newbase;
          if sum ne 0 then
            s := 1/sum;
            newcase := Sort([a*s : a in newbase]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
              
          for j in [1..4] do
            if sum ne 5*newbase[j] then
              s := 1/(sum-5*newbase[j]);
              newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..4] | k ne j]);
              if newcase lt basecase then continue i3; end if;
              if newcase eq basecase then auts:= true; end if;
            end if;
          end for;
        end for;
              
        // We got one!
              
        aa := a2/a1;
        bb := a3/a1;
        cc := a4/a1;
        f := x*(x-1)*(x-aa)*(x-bb)*(x-cc);
        if auts then
          autgroup := automorphisms111111(aa,bb,cc);
        else
          autgroup := [I];
        end if;
        
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
              
      end for;
    end for;
  end for;
  
  if 0 eq q mod 5 then
    f := x^5 - x;
    autgroup := automorphisms111111(K!2,K!3,K!4);

    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end if;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  assert checksum eq (q-2)*(q-3)*(q-4) / 720;
  
  return Clist;
end function;



//------------------------------------------------------------------------------


function genustwo2x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (2, ...)
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (2, ...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (2,1,1,1,1): q*(q-1)*(q-2)    /48
  // Galois type (2,2,1,1):   q*(q+1)*(q-2)    /16
  // Galois type (2,2,2):     (q-2)*(q^2-q-4)  /48

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);
  I := Matrix(2,[K|1,0,0,1]);
  negone := Matrix(2,[K|-1,0,0,1]);
  


  // First, type (2,1,1,1,1).
  checksum21111 := 0;

  // Get a list of representatives for all products of three or four linears 
  // under the action of PGL(2,K). The routine we call chooses reprentatives
  // so that the collection of automorphism groups of the representatives
  // is bounded.
  
  products := fourpoints1111(K);
    
  autgroups := Sort([a : a in {m[3] : m in products}]);

  for A in autgroups do
    // Compute representatives for the separable quadratics under the
    // action of A. For each rep, multiply the rep by the linear products 
    // with automorphism group A.
    
    productsA := [z : z in products | z[3] eq A];
    
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^2 : M in shortA];

    for a,b in K do
      quadratic := x^2 + a*x + b;
      D := Discriminant(quadratic);
      if IsSquare(D) then continue b; end if;
   
      autgroup := [I];
      for i in [1..#shortA] do
        g := Numerator(Evaluate(quadratic,rats[i]) * mults[i]);
        g := g/Coefficient(g,Degree(g));
        if g lt quadratic then continue b; end if;
        if g eq quadratic then
          autgroup cat:= [shortA[i]];
        end if;
      end for;

      for quartic in productsA do
        f := quartic[1]*quadratic;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum21111 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end for;
  end for;
  
  assert checksum21111 eq q*(q-1)*(q-2)/48;

  // Next, type (2,2,1,1).
  
  checksum2211 := 0;
  twoquadratics := fourpoints22(K);

  // twoquadratics contains orbit representatives for PGL(2,K) acting on
  // products of two distinct irreducible quadratics, and the automorphism
  // groups of the representatives come from a small set.

  autgroups := Sort([a : a in {m[3] : m in twoquadratics}]);


  for A in autgroups do
    // Compute representatives for pairs of distinct points in P^1(K) under
    // the action of A. For each rep, multiply the rep by the quartics with
    // automorphism group A.
    
    twoquadraticsA := [z : z in twoquadratics | z[3] eq A];
    
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^2 : M in shortA];
  
    for leadterms in [[0,1]] cat [[1,a] : a in K] do
      for b in K do
        quadratic := leadterms[1]*x^2 + leadterms[2]*x + b;
        // Note that this "quadratic" may be linear. 
        D := Discriminant(quadratic);
        if D eq 0 then continue b; end if;
        if not IsSquare(D) then continue b; end if;

        autgroup := [I];
        for i in [1..#shortA] do
          g := Numerator(Evaluate(quadratic,rats[i]) * mults[i]);
          g := g/Coefficient(g,Degree(g));
          if g lt quadratic then continue b; end if;
          if g eq quadratic then
            autgroup cat:= [shortA[i]];
          end if;
        end for;
      
        checksum2211 +:= #twoquadraticsA/#autgroup;

        for prodquad in twoquadraticsA do
          f := prodquad[1]*quadratic;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
  end for;
          
  assert checksum2211 eq q*(q+1)*(q-2)/16;


  // Next, we turn to Galois type (2,2,2)    
  checksum222 := 0;  
    
  factoredquadratics := [<[a[1] : a in Factorization(f[1])],f[2],f[3]> : f in twoquadratics];

  // Create a list of examples that we will need to consider in further
  // detail at the end. These will be products of three quadratics, such that
  // the mu-invariants of all pairs of quadratics are equal.
  
  trickyones := AssociativeArray();

  autgroups := Sort([a : a in {m[3] : m in factoredquadratics}]);

  for A in autgroups do
    // Compute representatives for the irreducible quadratics under the
    // action of A. Then run through the products of each one with the
    // elements of fproducts with automorphism group A.
    
    // Make a list of the pairs of quadratics with automorphism group A:
    
    factoredquadraticsA := [ <a[1], mu_invariant(a[1][1],a[1][2])> : a in factoredquadratics | a[3] eq A];
    
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^2 : M in shortA];

    for a,b in K do
      quadratic := x^2 + a*x + b;
      D := Discriminant(quadratic);
      if IsSquare(D) then continue b; end if;

      autgroup := [I];
      for i in [1..#shortA] do
        g := Numerator(Evaluate(quadratic,rats[i]) * mults[i]);
        g := g/Coefficient(g,Degree(g));
        if g lt quadratic then continue b; end if;
        if g eq quadratic then
          autgroup cat:= [shortA[i]];
        end if;
      end for;
      
      // OK, we've got a good quadratic. Let's pair it with all the elements
      // of  factoredquadraticsA.

      for quadpair in factoredquadraticsA do
        q1, q2 := Explode(quadpair[1]);
        mu12 := quadpair[2];
        
        if quadratic in [q1,q2] then continue quadpair; end if;
        
        mu13 := mu_invariant(q1,quadratic);
        mu23 := mu_invariant(q2,quadratic);
       
        keepit := false;
        case #{mu12,mu13,mu23}:
          when 3:
            if mu12 eq Sort([mu12,mu13,mu23])[1] then
              keepit := true;
            end if;

          when 2:
            if mu13 eq mu23 then
              keepit := true;
            end if;

          when 1:
            // The trickiest case. Postpone analysis.
            if mu12 in Keys(trickyones) then
              trickyones[mu12] cat:= [<q1,q2,quadratic>];
            else
              trickyones[mu12] := [<q1,q2,quadratic>];
            end if;
        end case;
            
        if keepit then
          f := q1*q2*quadratic;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum222 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end if;
      end for;
    end for;
  end for;


  // OK. Now we are left with the tricky ones.
  // A quick side note: We claim that we can do all this in O(q) memory.
  // So we need to know that there are O(q) tricky ones! 
  // If (q1,q2,q3) is tricky, then there are elements alpha1 and alpha2 of PGL2
  // such that alpha1 takes q1*q2 to q1*q3 and alpha2 takes q1*q2 to q2*q3.
  // This means there are beta1 and beta2 in PGL2 such that beta1 fixes q1 and
  // sends q2 to q3, and beta2 fixes q2 and sends q1 to q3.
  // We can show that over an algebraically closed field, for every pair of
  // disjoint degree-2 reduced effective divisors D1 and D2, there are at most
  // two degree-2 reduced effective divisors D3 such that there is an element of
  // PGL2 that fixes D1 and sends D2 to D3 and an element of PGL2 that fixes D2
  // and sends D1 to D3. Therefore, for each mu invariant, we get at most two
  // tricky ones *up to isomorphism over the algebraic closure*, but the number
  // of possible twists is bounded independent of q. So the total number of 
  // tricky ones is O(q).
  
  for mu in Keys(trickyones) do
    taken := [];
    for t in trickyones[mu] do
      f := t[1]*t[2]*t[3];
      move := Set(mapsbetweenpairsofquadratics([t[1],t[2]],[t[1],t[2]])
                  cat 
                  mapsbetweenpairsofquadratics([t[1],t[2]],[t[1],t[3]])
                  cat 
                  mapsbetweenpairsofquadratics([t[1],t[2]],[t[2],t[3]]));
      images := {};
      for M in move do
        g := Numerator(Evaluate(f,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])));
        g := g/Coefficient(g,6);
        images join:= {g};
      end for;
      f := Min(images);
      if not f in taken then
        taken cat:= [f];
        bool, autgroup := isomorphisms222(f,f);

        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum222 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;

      end if;
    end for;
  end for;

  assert checksum222 eq (q - 2)*(q^2 - q - 4)/48;

  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;


//------------------------------------------------------------------------------

function genustwo3x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (3, ...)
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (3, ...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (3,1,1,1): (q+1)*q*(q-1)    /18
  // Galois type (3,2,1):   (q+1)*q*(q-1)    / 6
  // Galois type (3,3):     (q^3-q-3)        /18

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  P1 := [1] cat [x-a : a in K];
  ns := nonsquare(K);
  basecubic := irreducible3(K);

  I := Matrix(2,[K|1,0,0,1]);
  T := Matrix(2,[K|0,-1, 1,-1]);

  // Galois type (3,1,1,1):
  checksum3111 := 0;

  // First, make a list of the orbits of P^1(K) under the action that
  // sends x to 1/(1-x). We represent elements a of K by the polynomial x-a,
  // and we represent the point at infinity by the polynomial 1.
  // IT IS IMPORTANT THAT THE SINGLETON ORBITS (if any) OCCUR AT THE END 
  // OF THE LIST.
  
  // The method depends on q mod 3...
  
  orbitlist := [[x,x-1,1]];
  
  case q mod 3:
    when 1:
      g := PrimitiveElement(K);
      zeta := g^((q-1) div 3);
      b := K!1;
      for i in [1..((q-1) div 3) - 1] do
        b *:= g;
        a := (-zeta*b + zeta^2)/(b-1);
        orbitlist cat:= [[x-a,x-1/(1-a),x-(a-1)/a]];
      end for;
      // Plus the two singleton orbits:
      orbitlist cat:= [ [x+zeta], [x+zeta^2] ];

    when 2:
      L := ext<K|2>;
      g := PrimitiveElement(L);
      zeta := g^((q^2-1) div 3);
      h := g^(q-1);
      b := K!1;
      for i in [1..((q+1) div 3) - 1] do
        b *:= h;
        a := K!((-zeta*b + zeta^2)/(b-1));
        orbitlist cat:= [[x-a,x-1/(1-a),x-(a-1)/a]];
      end for;

    when 0:
      t := K!1;
      if Trace(t,GF(3)) eq 0 then
        g := PrimitiveElement(K);
        repeat t*:=g; 
        until Trace(t) ne 0;
      end if;
      for b in K do 
        if b ne 0 and Trace(b) eq 0 then
          a := (t - b)/b;
          orbitlist cat:= [[x-a,x-1/(1-a),x-(a-1)/a]];
        end if;
      end for;
      // Plus the one singleton orbit
      orbitlist cat:= [[x+1]];
  end case;
  
  // First, points from 3 distinct orbits.
  // Choose first point in first orbit, then run through all points
  // in second and third orbits. Note that the first orbit must have
  // three elements in it because the smaller orbits occur last. Therefore
  // choosing the first element of the first orbit really does eliminate
  // automorphisms.
  
  autgroup := [I];
  
  for i in [1..#orbitlist-2] do
    a := orbitlist[i][1];
    for j in [i+1..#orbitlist-1] do
      for withinj in [1..#orbitlist[j]] do
        b := orbitlist[j][withinj];
        for k in [j+1..#orbitlist] do
          for withink in [1..#orbitlist[k]] do
            c := orbitlist[k][withink];
            f := basecubic*a*b*c;
         
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum3111 +:= 1/C[2]; 
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;

          end for;
        end for;
      end for;
    end for;
  end for;
  
  // Next, two points in one orbit and third point in a different one.
  // Choose the first two points of the orbit with two, and let the
  // third point range over all points in all other orbits. 

  for i in [1..#orbitlist] do
    orbit := orbitlist[i];
    if #orbit gt 1 then
      a := orbit[1]; 
      b := orbit[2];
      for c in P1 do 
        if not c in orbit then
          f := basecubic*a*b*c;
         
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum3111 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;

        end if;
      end for;
    end if;
  end for;
  
  // Finally, all three points in the same orbit.
  autgroup := [I,T,T^2];
  
  for i in [1..#orbitlist] do
    orbit := orbitlist[i];
    case #orbit:
      when 1: ;
      when 3: 
        f := basecubic*orbit[1]*orbit[2]*orbit[3];

        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum3111 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
    end case;
  end for;
  
  assert checksum3111 eq (q^3 - q)/18;

  // Now, Galois type (3,2,1).

  checksum321 := 0;
  
  // If q = 2 mod 3 then make a list of representatives for the orbits of P^1(K)
  // under the action that sends x to 1/(1-x). We represent the elements of
  // P^1(K) by monic polynomials of degree 1 and 0.
  // If q = 0 mod 3 or q = 1 mod 3, make a similar list of representatives, but
  // instead for orbits of monic irreducible quadratics.
  
  // The point of the two cases is that in each case, we are listing orbits of 
  // a fixed-point free action.
  
  autgroup := [I];

  case q mod 3:
    when 2:
      linearorbitreps := [R!1];
      L := ext<K|2>;
      g := PrimitiveElement(L);
      zeta := g^((q^2-1) div 3);
      h := g^(q-1);
      b := K!1;
      for i in [1..((q+1) div 3) - 1] do
        b *:= h;
        a := K!((-zeta*b + zeta^2)/(b-1));
        linearorbitreps cat:= [x-a];
      end for;

      // Now to enumerate all irreducible quadratics.

      for c in K do 
        if c ne 0 and c lt -c then
          for a in K do
            quad := x^2 + 2*a*x + a^2 - c^2*ns;
            partialf := basecubic*quad;
            
            for b in linearorbitreps do
              f := partialf*b;

              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                checksum321 +:= 1/C[2]; 
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;      
          end for;
        end if;
      end for;

    when 1:
      L := ext<K|2>;
      gen := PrimitiveElement(L);
      onethird := (q^2-1) div 3;
      zeta := gen^onethird;
      b := L!1;
      for i in [1.. onethird - 1] do
        b *:= gen; // b = gen^i
        if 0 ne i mod (q+1) and i lt ((i*q) mod onethird) then
          // In this case b is not an element of K (first condition) and
          // we have not already considered its conjugate (second condition)
          a := (-zeta*b + zeta^2)/(b-1);
          quad := MinimalPolynomial(a,K);
          
          // Now process this quadratic.
          partialf := basecubic*quad;
          for a in P1 do
            f := partialf*a;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum321 +:= 1/C[2]; 
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
      end for;

    when 0:
      t := K!1;
      if Trace(t,GF(3)) eq 0 then
        g := PrimitiveElement(K);
        repeat t*:=g; 
        until Trace(t) ne 0;
      end if;
      L := ext<K|2>;
      quadorbitreps := [];
      for b in L do 
        if b lt b^q and Trace(b) eq 0 then
          a := (t - b)/b;
          quad := MinimalPolynomial(a,K);
          
          // Now process this quadratic.
          partialf := basecubic*quad;
          for a in P1 do
            f := partialf*a;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum321 +:= 1/C[2]; 
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
      end for;

  end case;
  
  assert checksum321 eq (q^3 - q)/6;

  // Galois type (3,3):

  // The algorithm we implement here is not what is described in [Howe2025], 
  // although it is conceptually related. In the paper, we suggest fixing an
  // irreducible base cubic f1, and then looping through all irreducible cubics
  // f2 that are distinct from f1. Then we accept f1*f2 if it is the smallest 
  // element of the set {M(f1*f2)}, where M ranges over the elements of 
  // PGL(2,K) that either take the roots of f1 to themselves, or take the roots
  // of f2 to those of f1.

  // Computing the M that take f2 to f1 requires a fair amount of computation.
  // Instead, what we implement here loops over the elements M of PGL(2,K) and
  // sets f2 = M(f1). Given such an element M, there are 17 other elements of
  // PGL(2,K) that give a product f1*f3 that is in the same PGL(2,K) orbit as
  // f1*f2. These elements are A*M*B and A*M^-1*B, where A and B range over 
  // the automorphisms of f1. So we want only to consider M that are 
  // distinguished in the set of 18 "partner matrices" in this orbit.

  // Note that we choose f1 so that its automorphisms are the identity A1,
  // together with A2 = [0,-1;1,-1] and A3 = [1,-1;1,0].

  // We consider two types of M: First, the M all of whose partner matrices
  // have nonzero trace, and second, the M that have a partner matrix with 
  // trace 0.

  // For the first type, we normalize all of the partner matrices so that 
  // they have trace 1. If M = [a,b;c,d] with a+d=1, then the set of 
  // determinants of these normalized matrices is {D, D/(b - c - d)^2,
  // D/(a + b - c)^2}, where D = a*d-b*c. 

  // In characteristic 3 with M of the form [a,b;a+b+1,1-a], we just list
  // all 18 partner matrices and make sure M is the smallest.

  // In characteristic not 3, or in charaacteristic 3 if M is not of the
  // form [a,b;a+b+1,1-a], then this set of discriminants has at least two
  // distinct elements. We do not accept M unless either
  //   * there are three distinct values, and the determinant of M is
  //     the smallest, or
  //   * there are two distinct values, and the determinant of M is the
  //     non-repeated value.

  // Suppose M passes this test. There are six partner matrices with this
  // same determinant, and they are [a', b'; c', 1-a'] with the triple
  // (b',c',a') being one of the following:
  
  // [       b        ,            c    ,  a        ]
  // [      -b        ,           -c    , -a     + 1]
  // [           c    ,  2*a + b - c - 1,  a - c    ]
  // [          -c    , -2*a - b + c + 1, -a + c + 1]
  // [ 2*a + b - c - 1,       -b        , -a - b + 1]
  // [-2*a - b + c + 1,        b        ,  a + b    ]

  // And we simply check that [b,c,a] is the smallest of these
  // (lexicographically). If we loop through values of b first, then c,
  // then a, we can make sure that -b is at least as big as b, and that 
  // c and -c are at least as big as b, and that the values of a we loop
  // through satisfiy b <= 2*a + b - c - 1 and b <= -2*a - b + c + 1.
  // If equality holds in any of these, then we do the full comparison
  // of [b,c,a] with the the associated triple.

  // Next we turn to elements M of PGL(2,K) whose set of partner matrices
  // include ones with trace 0. We check that every such set of partner
  // matrices contains one that has trace 0 and that has nonzero diagonal
  // elements. Thus we can normalize M so that it is of the form [1,b;c,-1].

  // Given such an M, the partner matrices that also have trace 0 and 
  // nonzero diagonal elements are [1,b';c',-1] with (b',c') one of the
  // following:
  // [b,c]
  // [c/(1-c), (b-c+2)/(1-c)]  if c-1 is nonzero
  // [(c-b-2)/(b+1), b/(b+1)]  if b+1 is nonzero

  // So we just check whether [b,c] is the smallest of these.

  // -----

  // That gives us the set of M to consider. For the automorphism groups,
  // we check the automorphisms {A1,A2,A3] of f1 are automorphisms of
  // f1*f2 exactly when A2*M = M*A2 or M*A3. We check that this happens
  // exactly when M is of the form [c+d,-c;c,d] or [-d,c+d;c,d].

  // And we check that f1*f2 has an automorphism of order 2 if and only 
  // if one of the partner matrices has trace 0.


  checksum33 := 0;

  A1 := Matrix(2,[K|1,0,0,1]);
  A2 := Matrix(2,[K|0,-1,1,-1]);
  A3 := Matrix(2,[K|1,-1,1,0]);
  
  // First will look at trace-1 matrices with a + b - c - 1 and a + b - c nonzero.
  // These are exactly the ones that gives sets with no involutions.

  for b in K do 
    if b le -b then
      flagb := (b eq -b);
      for c in K do
        if b le c and b le -c then
          flagc1 := (b eq c);
          flagc2 := (b eq -c);
          bada1 := c-b;
          bada2 := c-b+1;
          for a in K do
            if a ne bada1 and a ne bada2 and b le 2*a + b - c - 1 and b le -2*a - b + c + 1 then
              // Check that determinant is nonzero and that we aren't taking the 
              // base cubic to itself.
              d := 1-a;
              det := a*d-b*c;
              
              if det ne 0 and (a ne d or b ne 0 or c ne 0) and [a,b,c,d] ne [1,-1,1,0] and [a,b,c,d] ne [0,1,-1,1] then
                 // Check that determinant is correct.
              
                n1 := (b - c - d)^2;
                n2 := (a + b - c)^2;

                invdet := 1/(a*d-b*c);              
                if n1 eq n2 or (invdet lt n1*invdet and invdet lt n2*invdet) then

                  // In characteristic 3, there is a 2-parameter family of M
                  // such that the 3 determinants are equal.
                  // [a, b; a+b+1, 1-a].
                  // So we want to check that [b,c] is smallest of the corresponding
                  // pairs of elements of the partner matrices.

                  if c eq a+b+1 and 0 eq q mod 3 then
                    equivalentM := [
                                     [      b    ,  a + b + 1 ],
                                     [      b + 1,  a + b     ],
                                     [      b - 1,  a + b - 1 ],
                                     [     -b    , -a - b - 1 ],
                                     [     -b + 1, -a - b + 1 ],
                                     [     -b - 1, -a - b     ],
                                     [  a        ,     -b + 1 ],
                                     [  a     + 1,     -b     ],
                                     [  a     - 1,     -b - 1 ],
                                     [  a + b    ,  a     - 1 ],
                                     [  a + b + 1,  a     + 1 ],
                                     [  a + b - 1,  a         ],
                                     [ -a        ,      b - 1 ],
                                     [ -a     + 1,      b + 1 ],
                                     [ -a     - 1,      b     ],
                                     [ -a - b    , -a     + 1 ],
                                     [ -a - b + 1, -a         ],
                                     [ -a - b - 1, -a     - 1 ]
                                   ];
                    if not [b,c] eq Sort(equivalentM)[1] then continue a; end if;                                   
                  end if;

                  flaga1 := (b eq  2*a + b - c - 1);
                  flaga2 := (b eq -2*a - b + c + 1);
              
                  // Do we need further checks for whether we have a distinguished M?
                  if flagb then
                    // compare [b,c,a] to [-b,-c,1-a]
                    if c gt -c or (c eq -c and a gt 1-a) then
                      continue a;
                    end if;
                  end if;
                  if flagc1 then
                    // compare [b,c,a] to [c, 2*a + b - c - 1, a-c]
                    if c gt 2*a + b - c - 1 or (c eq 2*a + b - c - 1 and a gt a - c) then
                      continue a;
                    end if;
                  end if;
                  if flagc2 then
                    // compare [b,c,a] to [-c, -2*a - b + c + 1, -a + c + 1]
                    if c gt -2*a - b + c + 1 or (c eq -2*a - b + c + 1 and a gt -a + c + 1) then
                      continue a;
                    end if;
                  end if;
                  if flaga1 then
                    // compare [b,c,a] to [2*a + b - c - 1, -b, -a - b + 1]
                    if c gt -b or (c eq -b and a gt -a - b + 1) then
                      continue a;
                    end if;
                  end if;
                  if flaga2 then
                    // compare [b,c,a] to [-2*a - b + c + 1, b, a + b]
                    if c gt b or (c eq b and a gt a+b) then
                      continue a;
                    end if;
                  end if;
              
                  // We have a good one! And we know it has no involutions.

                  newcubic := Numerator(Evaluate(basecubic,(-d*x+b)/(c*x-a))*(c*x-a)^3);
                  newcubic := newcubic/Coefficient(newcubic,3);
                  f := basecubic*newcubic;

                  // Only elements of PGL2 with nonzero trace that give automorphisms
                  // of order 3 are of the form [c+d, -c, c, d], so condition is that
                  // a = c + d and b + c = 0.
  
                  if (a eq c + d and b + c eq 0) then
                    autgroup := [I, A2, A3];
                  else
                    autgroup := [I];
                  end if;

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;
  
                  for C in Cs do
                    checksum33 +:= 1/C[2]; 
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;

               end if;
              end if;
            end if;
          end for;
        end if;
      end for;
    end if;
  end for;
  
  // OK. Now the sets that have involutions.
  
  for b, c in K do
    if b*c eq -1 then continue c; end if;
    if c ne 1 then
      newb := c/(1-c);
      newc := (b-c+2)/(1-c);
      if b gt newb or (b eq newb and c gt newc) then continue c; end if;
    end if;
    
    if b ne -1 then
      newb := (c-b-2)/(b+1);
      newc := b/(b+1);
      if b gt newb or (b eq newb and c gt newc) then continue c; end if;
    end if;

    // We have a good one! And we know it has an involution.
    M := Matrix(2,[1,b,c,-1]);


    newcubic := Numerator(Evaluate(basecubic,(x+b)/(c*x-1))*(c*x-1)^3);
    newcubic := newcubic/Coefficient(newcubic,3);
    f := basecubic*newcubic;

    autgroup := [I, PGLreduce(M)];
    if (c eq b+1) or (b eq -2 and c eq 2) then
      // We have automorphisms of order 3 as well.
      autgroup := [I, A2, A3] cat [PGLreduce(M*A) : A in [I,A2,A3]];
    end if;      

    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum33 +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;

  end for;
  
  assert checksum33 eq (q^3 - q - 3)/18;

  if outputfile ne "" then
    UnsetOutputFile();
  end if;
 
  return Clist;
end function;

//------------------------------------------------------------------------------


function genustwo4x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (4, ...)
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (4, ...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (4,1,1): q^2 * (q+1) /8
  // Galois type (4,2)):  q^2 * (q-1) /8.

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.


  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  ns := nonsquare(K);
  R<x>:=PolynomialRing(K);
  I := Matrix(2,[K|1,0,0,1]);
  
  quartics := fourpoints4(K : ns := ns);
  autgroups := Sort([a : a in {m[3] : m in quartics}]);

  checksum411 := 0;
  checksum42 := 0;

  for A in autgroups do
    // Compute representatives for the separable quadratics under the
    // action of A. For each rep, multiply the rep by the quartics with
    // automorphism group A.
    
    quarticsA := [z : z in quartics | z[3] eq A];
    
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^2 : M in shortA];
  
    for leadterms in [[0,1]] cat [[1,a] : a in K] do
      for b in K do
        quadratic := leadterms[1]*x^2 + leadterms[2]*x + b;
        // Note that this "quadratic" may be linear. 
        D := Discriminant(quadratic);
        if D eq 0 then continue b; end if;
        splitflag := IsSquare(D);

        orbit := [quadratic];
        autgroup := [I];
        for i in [1..#shortA] do
          g := Numerator(Evaluate(quadratic,rats[i]) * mults[i]);
          g := g/Coefficient(g,Degree(g));
          orbit cat:= [g];
          if g lt quadratic then continue b; end if;
          if g eq quadratic then
            autgroup cat:= [shortA[i]];
          end if;
        end for;
      
        if splitflag then
          checksum411 +:= #quarticsA/#autgroup;
        else
          checksum42 +:= #quarticsA/#autgroup;
        end if;
        for quartic in quarticsA do
          f := quartic[1]*quadratic;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
  end for;
          
  assert checksum411 eq q^2*(q+1)/8 and checksum42 eq q^2*(q-1)/8;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;
  
  return Clist;
end function;



//------------------------------------------------------------------------------            

function genustwo51(K : passback := true, curves := true, output := false, outputfile := "")

  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (5,1)
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (5,1),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (5,1): (q^3+q^2+q+1)/5

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.


  // Our strategy is to enumerate all irreducible quintics up to the action
  // of PGL(2,K) using the strategy in [Howe2024], using Frobenius divisors.
  // This takes time O(q^2). Then for each such quintic f, we output f as well
  // as f*(x-a) for all a in K.

  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  checksum51 := 0;
  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  zeta := PrimitiveElement(K);
  ns := nonsquare(K);  
  irred3 := irreducible3(K);
  I := Matrix(2,[K|1,0,0,1]);
  
  linears := [1] cat [x-a : a in K];

  // First deal with places with Frobenius functions of degree 1.
  // The paper tells us what they are.

  case q mod 5:
    when 0: 
      // Find an element of K of nonzero absolute trace.
      t := K!1;
      if Trace(t,GF(5)) eq 0 then
        repeat t*:=zeta;
        until Trace(t,GF(5)) ne 0;
      end if;
      A := Matrix(2,[K!1,1,0,1]);
      
      T := [<x^5 - x - t, [A^i : i in [0..4]]>];

    when 1: 
      rootof1 := zeta^((q-1) div 5);
      A := Matrix(2,[rootof1,0,0,1]);
      auts := [A^i : i in [0..4]];
      T := [<x^5 - zeta, auts>, <x^5 - zeta^2, auts>];
      
    when 4:
      KK := ext<K | 10>;
      zeta2 := PrimitiveElement(KK);
      // Want element of order 5*(q+1).
      // zeta2 has order q^10 - 1 
      xi := zeta2^((q^10-1) div (5*(q+1)));
      // Want an element ss of the quadratic extension of K in KK
      ss := xi^5;

      // Automorphisms:
      zeta := xi^(q+1); // Fifth root of 1
      r := (ss^(q) - zeta*ss)/(zeta-1);
      a := - ss - ss^(q);
      b := ss^(q+1);
      A := Matrix(2,[K|r-a,-b,1,r]);
      auts := [PGLreduce(A^i) : i in [0..4]];
      
      
      T := [<MinimalPolynomial( (ss*xi   + ss^(q))/(xi   + 1), K), auts>,
            <MinimalPolynomial( (ss*xi^2 + ss^(q))/(xi^2 + 1), K), auts>];
    else
      T := [];
  end case;
  
  // Process these.
  for quinticauts in T do
    quintic, auts := Explode(quinticauts);
    shortauts := [M : M in auts | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortauts];
    dens := [M[2,1]*x + M[2,2] : M in shortauts];

    for linear in linears do
      orbit := [linear];
      autgroup := [I];
      for i in [1..#shortauts] do
        g := Numerator(Evaluate(linear,rats[i]) * dens[i]);
        g := g/Coefficient(g,Degree(g));
        orbit cat:= [g];
        if g eq linear then
          autgroup cat:= [shortauts[i]];
        end if;
      end for;
      
      if linear eq Sort(orbit)[1] then
        f := quintic*linear;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum51 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
        
      end if;
    end for;
  end for;
  
  // Now turn to the irreducible quintics over K with Frobenius functions
  // of degree 2; i.e., with no automorphisms.
  
  autgroup := [I];
  
  // We need reps for degree-3 divisors over K up to PGL(2,K).
  // 3*oo
  // 2*oo + 0
  // oo + 0 + 1
  // oo + irred2
  // irred3

  // D = 3*oo. The paper tells us exactly what to do in this case.
  // There are only two associated functions:
  // (x^2 + y^2)/(xy) and (x^2 + ns*y^2)/(xy), where ns is a nonsquare in K.


  for F in [(x^2+1)/x, (x^2+ns)/x] do
    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;


  // D = 2*oo + 0. The paper tells us exactly what to do in this case.
  // The functions to consider are
  // (x^2 + sx)/(x + 1)  where s!=1
  
  for a in K do 
    if a eq 1 then continue a; end if;
    F := (x^2+a*x)/(x+1);
    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;


  // oo + 0 + 1
  // oo + irred2
  // irred3

  // D = oo + 0 + 1.
  // r := 2;
  // p = y*z*(y-z)
  // want (y*h - c*p)/(z*h) where h has degree 2 and gcd with p is z
  // and where c is nonzero and cp != yh mod z^2
  // c*y^2*z != y*h mod z^2
  // h = z*(y + b*z)
  // c*y^2*z != y^2*z  so c!=1
  // (y*z*(y + b*z) - c*y*z*(y-z)) / (z^2*y + b*z^3)
  // (y*(y + b*z) - c*y*(y-z)) / (z*y + b*z^2)
  // (y^2 + b*y*z - c*y^2 + c*y*z) / (z*y + b*z^2)
  // ((1-c)*y^2 + (b+c)*y) / (y + b)   b arbitrary, c nonzero, non-1

  // Elements of PGL2 that fix D  
  Dmatrixauts := [ Matrix(2,[K |  1,  0, 0,  1]),
                   Matrix(2,[K |  0, -1, 1, -1]),
                   Matrix(2,[K |  1,  0, 1, -1]),
                   Matrix(2,[K |  0,  1, 1,  0]),
                   Matrix(2,[K |  1, -1, 1,  0]),
                   Matrix(2,[K | -1,  1, 0,  1]) ];
             
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             
             

  for b,c in K do
    if c^2 eq c then continue c; end if;
    F := ((1-c)*x^2 + (b+c)*x)/(x + b);  

    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;
  
  
  // D = oo + irred2.
  // r := 2;
  // p = z*(y^2 - ns*z^2)
  // want (y*h - c*p)/(z*h) where h has degree 2 and gcd with p is z
  // and where c is nonzero and cp != yh mod z^2
  
  // First, h = z^2.
  // c*z*(y^2 - ns*z^2) != 0 mod z^2
  // c*y^2 != 0 mod z
  
  // Second, h = z*(y + b*z).
  // c*z*(y^2 - ns*z^2) != y*z*(y + b*z) mod z^2
  // c*z*y^2 - c*ns*z^3 != y^2*z + b*y*z^2 mod z^2
  // c*z*y^2 != y^2*z  mod z^2
  // c != 1, b arbitrary

  // y*(y + b) - c*(y^2 - ns)    y^2 + b*y - c*y^2 + ns*c
  // ------------------------- = ------------------------
  // (y + b)                     y + b
  
  
  // Elements of PGL2 that fix D  
  // y --> -y
  Dmatrixauts := [ Matrix(2,[K |  1, 0, 0, 1]),
                   Matrix(2,[K | -1, 0, 0, 1]) ];
             
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             
             


  // First, h = z^2:

  for c in K do
    if c eq 0 then continue c; end if;
    F := c*x^2 + x - c*ns;

    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;
  
  // Next, h =  h = z*(y + b*z)
    
  for b,c in K do
    if c^2 eq c then continue c; end if;
    F := ((1-c)*x^2 + b*x + ns*c)/(x + b);
    
    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;
 

  // D = irred3.
  // r := 2;
  // p = irred3
  // want (y*h - irred3)/(z*h) where h is monic, degree 2, coprime to z
  // h = y^2 + a*y + b 
  
  // Elements of PGL2 that fix irred3

  Dmatrixauts := [I,Matrix(2,[0,-1,1,-1]), Matrix(2,[1,-1,1,0])];
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             

  for a,b in K do
    F := (x^3 + a*x^2 + b*x - irred3)/(x^2 + a*x + b);
    
    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue b; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for linear in linears do
          f := quintic*linear;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum51 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;


  assert checksum51 eq (q^3+q^2+q+1)/5;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;
  
  return Clist;
end function;


//------------------------------------------------------------------------------

function genustwo6(K : passback := true, curves := true, output := false, outputfile := "")

  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-2 curves over K with Weierstrass
  //        divisor of Galois type (6)
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (6),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (6): (q^3 + q - 1)/6

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.


  // We produce the sextics by applying elements of PGL(2,F_{q^2}) to 
  // the root in F_{q^3} of an irreducible cubic over F_q.
  // We only list elements of PGL(2,F_{q^2}) up to the left action
  // of PGL(2,K).
  
  // IN ADDITION: Galois conjugate elements of PGL(2,F_{q^2}) give
  // isomorphic sextics, as do rotations of the vector specifying
  // where oo, 0, and 1 go to. So how do we get a unique representative
  // for an element of PGL(2,F_{q^2}) specified by (r, s, t)?
  
  // First: If exactly two of r,s,t lie in K, rotate so that they are the first
  // two elements. After using PGL(2,L), we get  oo, 0, beta + a. Conjugation
  // gives oo, 0, -beta + a, rescaling by -1 gives oo, 0, beta - a, so we need
  // only choose a up to sign.
  
  // Second: If exactly one of r,s,t lies in K, rotate so that it is in the 
  // first position. We get oo, beta, b*beta + a with b nonzero and with 
  // (a,b)!=(0,1). Conjugation and multiplication by -1 gives
  // oo, beta, b*beta - a, so once again choose a only up to sign.

  // Third: If two of r,s,t are conjugate, rotate so that they are the first
  // two. We get beta, -beta, theta for theta in beta action reps. 
  // Negating and conjugating gets us in the same beta orbit, so
  // all theta are good.

  // Fourth: Left with the case where none of r,s,t lies in K, and no two are
  // conjugate. We demand that if (r,s,t) is in the right order then we only
  // take it if it "comes before" the normal form of its conjugate.
  // Given that r = beta and s is a beta orbit rep,
  // to normalize the conjugate we start with (-rbar, -sbar, -tbar).
  // -rbar = beta so that's good.
  // -sbar is in the same orbit as s so we find the transformation
  // that fixes beta and takes -sbar to s, then apply it to t to get t',
  // and we demand that t \le t'.
   
  // Compute the 3 cross ratios
  // jr = (r,s,t,rbar), js = (s,t,r,sbar), jt = (t,r,s,tbar). 
  // If exactly two are equal, normalize by insisting that they are the
  // first two.

  // If they are all equal, we're good, because rotating will not change
  // the class of the triple.
  
  // Summarizing these last two conditions, we see that if j1 = j2 then
  // we accept the triple as being normalized.

  // So now assume that all the j's are distinct.
  // If two are conjugates of one another, demand they are first.
  
  // So now at this point either all three are equal, or the three sets 
  // {jr,jrbar}, {js,jsbar}, {jt,jtbar} are distinct. In latter case, rotate so
  // that {jr,jrbar} is first in some ordering. Left with the case where 
  // jr = js = jt
  
  // r      s      t      rbar
  // s      t      r      sbar
  // t      r      s      tbar
  
  // so there's an order-3 element of PGL(2,Fq2) that rotates r, s, t
  // and rbar,sbar,tbar. So it must be an element of PGL(2,K).
  // And this means that the normal form of (r,s,t) does not depend
  // on whether we rotate the triple first, so we only see each normal
  // form once.

  // r      s      t      rbar
  // sbar   tbar   rbar   s

  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  checksum6 := 0;
  Clist := [];
  
  q := #K;
  ns := nonsquare(K);
  R<x>:=PolynomialRing(K);
  L<beta>:=ext<K | x^2 - ns>;
  M := ext<L | 3>;
  alpha := Roots(irreducible3(K),M)[1][1];
  I := Matrix(2,[K|1,0,0,1]);

  
  // First: triples (oo, 0, beta + a).
  // The ones with a nonzero...

  autgroup := [I];  
  for a in K do
    if a eq 0 or a gt -a then continue a; end if;
    
    // Process it:
    aa := beta+a;
    bb := 0;
    cc := 0;
    dd := 1;
    f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum6 +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end for;
    

  // ... and the ones with a = 0, in which case we get an involution.

  autgroup := [I, Matrix(2,[K| -1,0,0,1])];
  aa := beta;
  bb := 0;
  cc := 0;
  dd := 1;
  f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
  if curves then
    Cs := curves_from_divisor(f,autgroup);
  else
    Cs := [<f,#autgroup,autgroup>];
  end if;

  for C in Cs do
    checksum6 +:= 1/C[2]; 
    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
    if passback then Clist cat:= [C]; end if;
  end for;

 
  
  // Second: triples (oo, beta, theta), where theta = b*beta + a with a distinct
  // up to sign and b nonzero and with (b,a) != (1,0).
  // The ones with a nonzero...
  
  autgroup := [I];  

  for a,b in K do
    if a gt -a or a eq 0 or b eq 0 then continue b; end if;
    aa := (b*beta+a)-beta;
    bb := beta;
    cc := 0;
    dd := 1;
    f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum6 +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end for;
  
  // ... and the ones with a = 0, in which case we get an involution.
  
  autgroup := [I, Matrix(2,[K| -1,0,0,1])];
  
  for b in K do
    if b eq 0 or b eq 1 then continue b; end if;
    
    aa := (b*beta)-beta;
    bb := beta;
    cc := 0;
    dd := 1;
    f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum6 +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end for;
  
  // Third: triples (beta, -beta, theta) for theta unique up to the action of
  // the subgroup of PGL(2,K) that fixes beta.
  
  orbitreps := betaorbitreps(K,beta);
  // This is a set of orbit representatives for the action on 
  // P^1(L)\{beta,beta^q} of the subgroup of PGL(2,K) that fixes beta.
  // Note that this has size O(q). 
  
  // Remove the rational orbit.
  orbitreps := [a : a in orbitreps | not a in K];
  
  for theta in orbitreps do
    // We have an automorphism.
    aut := Matrix(2,[K|ns + Norm(theta,K), -ns*Trace(theta,K), 
                     Trace(theta,K), -ns -Norm(theta,K)]);
    autgroup := [I, aut];
    
    aa := beta*(beta+theta);
    bb := beta*(theta-beta);
    cc := beta+theta;
    dd := beta-theta;
    
    f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum6 +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end for;
    
    
  // We will have beta, eta, theta. We want to distiguish between this ordered
  // triple and its rotations. 
  
  for eta in orbitreps do
    
    normeta := Norm(eta,K);
    traceeta := Trace(eta,K);
    etaq := traceeta-eta;
    
    aaa := (ns + normeta)/traceeta;
    bbb := aaa^2 - ns;
    assert eta eq aaa + bbb/(etaq - aaa);
    
    // The map x --> aaa + bbb/(x - aaa) takes beta^q to beta and eta^q to eta.
    
    // Compute as much of our crossratios as we can at this point.
    jj1 := (beta + eta) / (2 * beta);
    jj2 := (eta - beta) / (eta - etaq);
    jj3 := 1 / (eta - beta);
    

    // Now we want theta to run over all elements of L that are not in K
    // and not equal to beta or beta^q and not equal to eta or eta^q.
    
    betaq := beta^q;

    for theta in L do
      if theta in K then continue theta; end if;
      if theta eq beta or theta eq betaq then continue theta; end if;
      if theta eq eta  or theta eq etaq  then continue theta; end if;
      
      // Also check that [beta, eta, theta] is minimal under conjugation.
      thetaq := theta^q;
      thetaprime := aaa + bbb/(thetaq - aaa);
      if theta gt thetaprime then continue theta; end if;

      tracetheta := Trace(theta,K);
      normtheta := Norm(theta,K);
      
      j1 := jj1 *   (beta - theta) / ( eta - theta);
      j2 := jj2 *   (etaq - theta) / (beta - theta);
      j3 := jj3 *   (eta  - theta) * (beta - thetaq) / (theta - thetaq) ;

      if #{j1,j2,j3} eq 1 then
        // Do we have an involution?
        aut := I;
        order := 1;
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          order := 2;
        
          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
        end if;      

        autentries := [ ns*eta - 3*beta*eta*theta + beta*theta^2 + eta^2*theta,
                       -ns*eta^2 + ns*eta*theta - ns*theta^2 + beta*eta^2*theta + beta*eta*theta^2 - eta^2*theta^2,
                        ns - beta*eta - beta*theta + eta^2 - eta*theta + theta^2,
                       -ns*theta - beta*eta^2 + 3*beta*eta*theta - eta*theta^2];
        c := autentries[3];
        if c eq 0 then c := autentries[4]; end if;
        aut3 := Matrix(2,[K! (a/c) : a in autentries]);

        gen := aut*aut3;
        autgroup := [gen^i : i in [0..3*order-1]];
        
        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum6 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;

        continue theta;
      end if;
        
      if #{j1,j2,j3} eq 2 and j1 eq j2 then
        // do we have an involution?
        autgroup := [I];
        order := 1;
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          order := 2;

          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
          autgroup := [I, aut];
        end if;      

        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum6 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;

        continue theta;
      end if;

      // So now the j's are distinct.
      if (j1 eq j2^q) or (j2 eq j3^q) or (j3 eq j1^q) then
        if j1 eq j2^q then
        // Do we have an involution?
          autgroup := [I];

          if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
            aut2eltseq := [
                          -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                           beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                          -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                           beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
            c:=aut2eltseq[3]; 
            if c eq 0 then c:=aut2eltseq[4]; end if;
            aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
            autgroup := [I, aut];
          end if;      

          aa := beta*(eta-theta);
          bb := eta*(theta-beta);
          cc := eta-theta;
          dd := theta-beta;

          f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            checksum6 +:= 1/C[2]; 
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end if;
        continue theta;
      end if;
      
      p1 := MinimalPolynomial(j1,K);
      p2 := MinimalPolynomial(j2,K);
      p3 := MinimalPolynomial(j3,K);
      
      // These are distinct. Only continue to process if p1 is the smallest.
      
      if p1 eq Sort([p1,p2,p3])[1] then
      
        // Do we have an involution?
        autgroup := [I];
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
          autgroup := [I, aut];
        end if;      

        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        f := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          checksum6 +:= 1/C[2]; 
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
        
      end if;
    end for;
  end for;
  
  assert checksum6 eq (q^3 + q - 1)/6;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;
  
  return Clist;
end function;


/*
================================================================================
Functions for getting all hyperelliptic curves of genus two.
================================================================================
*/

function hyperelliptic2(K : passback := true, curves := true, output := false, outputfile := "");
  // Return the union of the output of all the various genustwoxx functions.
  
  Clist    := genustwo6 (K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genustwo51(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genustwo4x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genustwo3x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genustwo2x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genustwo1x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  return Clist;
end function;


