// Hyperelliptic3.magma
// Version 2.01
// 6 July 2025

// Code related to two papers:

// [Howe2025]
// Everett W. Howe:
// Enumerating hyperelliptic curves over finite fields in quasilinear time,
// Res. number theory 11, 26 (2025). Proceedings of ANTS XVI.
// https://doi.org/10.1007/s40993-024-00594-7

// [Howe2024]
// Everett W. Howe:
// Enumerating places of P1 up to automorpshisms of P1 in quasilinear time,
// arXiv:2407.05534 [math.NT]
// https://doi.org/10.48550/arXiv.2407.05534





/* 
================================================================================
This collection of Magma routines is designed to produce a list of all genus-3
hyperelliptic curves over a given finite field of odd characteristic, up to
isomorphism. The strategy is to compute a complete set of unique representatives
for the orbits of PGL(2,GF(q)) acting on monic homogeneous separable octic 
polynomials of a given "Galois type," as defined in [Howe2025], and to then 
produce the one or two distinct double covers of P^1 ramified at the roots of
the given polynomials.

The routines in this file have been completely rewritten since the first version
was released in January 2024. Some of the changes are to incorporate ideas from
[Howe2024], and one of the goals of this version is to reduce the memory
requirements of the routines to O(q^2) when the results are not returned in a
variable but rather printed to standard output or to a file. 

We group the Galois types by the largest degree they include, and compute all
of the genus-3 hyperelliptic curves for each of these grouping of Galois types.
The programs for computing the curves are named for the types in the grouping:

genusthree1x()
genusthree2x()
genusthree3x()
genusthree4x()
genusthree5x()
genusthree6x()
genusthree71()
genusthree8()

We also have a combined function that runs all of the above:

hyperelliptic3()

(However, unless the optional parameter "efficient" is set to false, modifed
versions of the "genusthree" routines will be run when hyperelliptic3 is called:
genusthree3x will not output the Galois type (3,2,2,1), genusthree4x will not
output the Galois type (4,3,1), genusthree5x will not output the Galois type
(5,2,1), and genusthree71 *will* output these three Galois types, in addition to
type (7,1).)

If one is interested not in the curves but rather in the orbits of Galois-stable
sets of eight elements of P^1 over the algebraic closure, one can set the
optional parameter "curves" of these functions to "false".

If one does not want the output of the functions returned in a variable, one 
can set the optional paramater "passback" to "false".

If one wants the output to be printed, one can set the optional parameter
"output" to "true". And if one wants the output printed to a file instead of
to standard out, one can set the optional parameter "outputfile" to the name
of the desired file.

When the output is returned in a variable, each element of it is a triple
<f, n, G>, where f is a polynomial, G is a finite subgroup of PGL(2,GF(q))
specified by giving matrix representations of its elements, and n is either #G
or twice #G (as explained below). When the output represents a Galois-stable set
of elements of P^1, G is the stabilizer of this set in PGL(2,GF(q)) and n = #G.
When the output represents a curve, G is the image in PGL(2,GF(q)) of the
automorphism group of the curve, and n is twice the order of G, so that n is 
the order of the automorphism group of the curve.

When output is printed instead of returned in a variable, the elements are 
shortened. The polynomial f is represented by its sequence of coefficients as
given by Eltseq(f), and the group G is not listed. 

We also will need to have orbit representatives for the action of PGL(2,GF(q))
on some polynomials of smaller degrees. Mostly we get these functions by loading
the file "Hyperelliptic2.magma" or by incorporating sections of the code
included there, but there is one additional Galois type that we need here:

fourpoints31()  : Given K, return orbit representatives for PGL(2,K) acting
                  on homogeneous quartics that factor as an irreducible cubic
                  times a linear.

We also obtain many utility functions from Hyperelliptic2.magma, which are
listed in the introductory comments of that file. In addition, we introduce a
few more:

automorphisms11111() :
                  Given a set of five distinct points in P^1(K), compute the
                  PGL(2,K) stabilizer of the set.
                  
automorphisms11111111() :
                  Given a set of eight distinct points in P^1(K), compute the
                  PGL(2,K) stabilizer of the set.

orbitlabel()    : Given an element of PGL(2,L), where L is the quadratic 
                  extension of a finite field K, compute the "orbit label" of
                  the element as defined in Section 2.5 of [Howe2024]. This is
                  a label that depends only on the PGL(2,K) orbit the element
                  lies in, and that distinguishes this orbit.

================================================================================

VERSION HISTORY:

Version 2.01, 6 July 2025

Corrected an error in genusthree71() that would, in certain circumstance,
cause the program to fail with an error for prime powers congruent to 1 mod 7.

--------------------------------------------------------------------------------
Version 2.0, 8 June 2025

Completely rewritten. The old "eightpoints" functions have been replaced by the
"genusthree" functions. Also, if the functions are called with the "passback"
flag set to false, the memory usage of the programs will be bounded by O(q^2).

Removed many utility functions that were not longer of utility.

Added a number of utility functions, some of which previously existed in 
Hyperelliptic2.magma, but which were not used there.

Added a function to verify that the output is correct.

--------------------------------------------------------------------------------
Version 1.01, 11 March 2024.
Corrected error in fivepoints5(). For the degree-5 irreducible polynomials with
nontrivial autormorphisms, the previous version gave incorrect matrices for the
elements of PGL_2 that fix the polynomial. This did not affect the output of any
of the eightpoints*() functions, because no automorphism of an irreducible 
degree-5 factor of a separable degree-8 polynomial lifts to an automorphism of
the full polynomial.

Also edited some comments throughout the file.

--------------------------------------------------------------------------------
Version 1.0, 25 January 2024.
First released version. Revision/cleanup/simplification of initial code.



--------------------------------------------------------------------------------

To do: 

* A serious code review to check for accuracy and clarity.
* Go through and check comments for thoroughness and accuracy.

================================================================================
*/



/*
================================================================================
Loading genus-2 code.
================================================================================
*/

load "Hyperelliptic2.magma";

/*
================================================================================
Utility functions.
================================================================================
*/

//------------------------------------------------------------------------------

function fourpoints31(K);
  // Return all effective degree-4 divisors on P^1 that consist of a single
  // rational point plus three Galois conjugate elements of the cubic extension,
  // up to PGL(2,K). The (q^3-q)/3 cubics and (q+1) rational points give
  // q*(q-1)*(q+1)^2/3 such divisors. Diving by #PGL2 gives (q + 1)/3. This will
  // be the weighted sum of the divisors we output.
  
  // Put the rational point at infinity. This leaves us with a cubic. In char 3,
  // this is x^3 + a2*x^2 + a1*x + a0 and we know a0!=0 and one of a2 and a1 is
  // nonzero.
  //
  // If a2 is nonzero scale so that it is 1. Then shift so that a1 = 0. This
  // example has no automorphisms.
  //
  // If a2 = 0 then scale so that a1 = -1 or a1 = -ns.
  // First try -ns: It's impossible, because x^3 - ns*x is an
  // F3 linear map with trivial kernel, so we'll always have a root.
  // So we have x^3 - x + a, where a is one of three choices, with absolute 
  // trace 0, 1, or 2. But trace 0 has a root. And by replacing x with -x, we
  // may assume a0 has absolute trace 1.
  
  // In other characteristics: Shift so trace is 0. If a1 is nonzero scale so
  // a1 = a0. In this case there are no automorphisms. But if a1 = 0 then we 
  // have x^3 - a0. For this to be irreducible we must have q = 1 mod 3. In this
  // case there are two classes of such cubics, and the automorphism group of 
  // the degree-4 divisor has order 3.

  q := #K;
  R<x>:=PolynomialRing(K);
  I := Matrix(2,[K|1,0,0,1]);
  polys31 := [];
  prim := PrimitiveElement(K);

  if 0 eq q mod 3 then
    badvals := {a^3 + a^2  : a in K};
    badvals := Sort([a : a in badvals]);
    for a in K do 
      if not a in badvals then
        polys31 cat:= [<x^3 + x^2 - a, 1, [I]>];
      end if;
    end for;
    p,e := Explode(Factorization(q)[1]);
    nonzerotrace := K!1;
    while Trace(nonzerotrace,GF(3)) eq 0 do
      // Multiply by the primitive element.
      nonzerotrace *:= prim;
    end while;
    A1 := Matrix(2,[K|1,1,0,1]);
    A2 := Matrix(2,[K|1,2,0,1]);
    polys31 cat:= [<x^3 - x + nonzerotrace, 3, [I,A1,A2]>];
  else
    badvals := {a^3/(a+1) : a in K | a ne -1};
    badvals := Sort([a : a in badvals]);
    for a in K do 
      if not a in badvals then
        polys31 cat:= [<x^3 - a*x - a, 1, [I]>];
      end if;
    end for;
    if 1 eq q mod 3 then
      zeta := Roots(x^2+x+1)[1][1];
      A1 := Matrix(2,[zeta,0,0,1]);
      A2 := Matrix(2,[zeta^2,0,0,1]);
      p,e := Explode(Factorization(q)[1]);
      noncubeexponent := q-1;
      while 0 eq noncubeexponent mod 3 do
        noncubeexponent div:= 3;
      end while;
      noncube := prim^noncubeexponent;
      polys31 cat:= [<x^3 - noncube,   3, [I,A1,A2]>,
                     <x^3 - noncube^2, 3, [I,A1,A2]>];
    end if;
  end if;
  
  assert &+[1/m[2] : m in polys31] eq (q + 1)/3;
  return polys31;
end function;


//------------------------------------------------------------------------------

function orbitlabel(K,L,beta,biggamma)
  // Compute the orbit label of an element of PGL(2,GF(q^2)) under the action
  // of PGL(2,GF(q)), as defined in Section 2.5 of [Howe2024].
  
  // L is the quadratic extension of a finite field K of odd characteristic,
  // say with q elements, beta is an element of L with beta^q = -beta, and
  // biggamma is an element of PGL(2,L) represented by a matrix.

  // Suppose biggamma sends oo, 0, and 1 to infinity, zero, one.

  // If infinity lies in P^1(K) then use PGL(2,K) to move infinity, zero, one to
  // one of:
  // (oo, 0, 1)
  // (oo, 0, beta + a)
  // (oo, beta, theta)
  // and return the label [0, zero, one].
  
  // If infinity does not lie in P^1(K) then use PGL(2,K) to move infinity to
  // beta. 
  // If zero = oo, move it to a finite point and continue:
  // If zero = -beta, then return [1, 0, Norm_{L/K}( (one+beta)/(one-beta) )].
  // Otherwise, return [1, Norm_{L/K}( (zero+beta)/(zero-beta) ),
  //       ((one + beta)/(one - beta)) * ((zero - beta)/(zero + beta))].
  
  a,b,c,d := Explode(Eltseq(biggamma));
  infinity := [a,c];
  zero := [b,d];
  one := [a+b,c+d];
  
  // Normalize the first element.
  // If c = 0 then we're already done.
  if c eq 0 or a/c in K then
    if c ne 0 then 
      a,b,c,d := Explode([c^2,c*d,0,b*c-a*d]);
      infinity := [a,c];
      zero := [b,d];
      one := [a+b,c+d];
    end if;
    // So now c = 0.
    // Is zero in K?
    
    if b/d in K then
      // Move zero to zero.
      b := L!0; // others remain the same.
      infinity := [a,c];
      zero := [b,d];
      one := [a+b,c+d];

      if one[1]/one[2] in K then 
        return [L!0,0,1];
      else
        t := Trace(one[1]/one[2],K)/2;
        s := (one[1]/one[2] - t)/beta;
        assert s in K;
        return [L!0,0,one[1]/one[2]/s];
      end if;
      
    else
      // Move zero to beta.
      t := Trace(b/d,K)/2;
      s := (b/d-t)/beta;
      a,b,c,d := Explode([a,b-t*d,0,s*d]);
      infinity := [a,c];
      zero := [b,d];
      one := [a+b,c+d];
      assert zero[1]/zero[2] eq beta;
      return [L!0,beta,one[1]/one[2]];
    end if;

  else
    // infinity is not in K. So move it to beta.
    t := Trace(a/c,K)/2;
    s := (a/c-t)/beta;
    // infinity = t + s*beta
    a,b,c,d := Explode([a-c*t, b-d*t, s*c, s*d]);
    infinity := [a,c];
    zero := [b,d];
    one := [a+b,c+d];
    assert infinity[1]/infinity[2] eq beta;
    
    if d eq 0 then
      a,b,c,d := Explode([a+c*beta^2, b+d*beta^2, a+c, b+d]);
      infinity := [a,c];
      zero := [b,d];
      one := [a+b,c+d];
      assert infinity[1]/infinity[2] eq beta;
      assert d ne 0;
    end if;
    

    if b/d eq -beta then
      return [L!1,0, Norm( (one[1]+beta*one[2])/(one[1]-beta*one[2]),K)];
    else
      return [L!1, Norm( (zero[1]+beta*zero[2])/(zero[1]-beta*zero[2]), K),
        ((one[1] + beta*one[2])/(one[1] - beta*one[2]))
          *((zero[1] - beta*zero[2])/(zero[1] + beta*zero[2]))];
    end if;
  end if;
end function;  


//------------------------------------------------------------------------------  
function automorphisms11111(aa,bb)

  // Compute the PGL(2,K) stabilizer of the set {oo, 0, 1, aa, bb}

  K := Parent(aa+bb);
  q := #K;
  
  I := Matrix(2,[K|1,0,0,1]);

  r := [0, 1, aa, bb];

  // Compute (1/32 times) the j-invariants of the four subsets of
  // {oo, 0, 1, aa, bb} that contain oo and three other elements. These first
  // values are used repeatedly in the calculation of the j-invariants.
  
  r12 := 1;
  r13 := aa^2;
  r14 := bb^2;
  r23 := (aa-1)^2;
  r24 := (bb-1)^2;
  r34 := (aa-bb)^2;

  jset := { (r12 + r13 + r23)^3 / (r12*r13*r23),
            (r12 + r14 + r24)^3 / (r12*r14*r24),
            (r13 + r14 + r34)^3 / (r13*r14*r34),
            (r23 + r24 + r34)^3 / (r23*r24*r34)};

  // If the set has nontrivial automorphisms, there can be at most two
  // distinct j-invariants here. So return [I] if there are more.

  if #jset gt 3 then return [I]; end if;
  
  // Add in the j-invariant of the set {0,1,aa,bb} and check again.
    
  jset join:= {quickj4([r[1],r[2],r[3],r[4]])};
  
  if #jset gt 3 then return [I]; end if;

  // At this point there may well be nontrivial automorphisms. Let's find them.

  lfts := [];
  
  rootsf := [ [a,1] : a in r ];
  rootsf cat:= [[1,0]]; 
  a, b, c, d, e := Explode(rootsf);

  for i,j,k in [1..5] do 
    if #{i,j,k} eq 3 then
      A := rootsf[i];
      B := rootsf[j];
      C := rootsf[k];
      // Find r,s,t,u such that (r*x + s)/(t*x + u) sends a to A, b to B, c to C
          
      M := Matrix(3,4,[a[1]*A[2],a[2]*A[2],-a[1]*A[1],-a[2]*A[1],
                       b[1]*B[2],b[2]*B[2],-b[1]*B[1],-b[2]*B[1],
                       c[1]*C[2],c[2]*C[2],-c[1]*C[1],-c[2]*C[1] ]);
      BB := Basis(Nullspace(Transpose(M)))[1];
      r := BB[1];
      s := BB[2];
      t := BB[3];
      u := BB[4];
          
      imaged := [r*d[1] + s*d[2], t*d[1] + u*d[2]];
      imagee := [r*e[1] + s*e[2], t*e[1] + u*e[2]];
      
      // These are images in P^1(K). Normalize the representatives.
      
      if imaged[2] ne 0 then imaged := [imaged[1]/imaged[2],1]; else imaged := [K!1,0]; end if;
      if imagee[2] ne 0 then imagee := [imagee[1]/imagee[2],1]; else imagee := [K!1,0]; end if;
      if imaged in rootsf and imagee in rootsf then lfts cat:= [[r,s,t,u]]; end if;
    end if;
  end for;

  return Sort([PGLreduce(Matrix(2,z)) : z in lfts]);
end function;
 


//------------------------------------------------------------------------------


function automorphisms11111111(f);
  // Given a separable polynomial of degree 7 or 8 with all roots rational, find
  // the PGL(2,K) stabilizer of its roots in P^1 (plus oo, if the degree is 7).
  // We only call this function when we know there are nontrivial automorphisms.
  // If we want to use it in other situations, we might want to add some initial
  // testing to avoid doing the whole computation when the answer is easily
  // seen to be trivial. The structure of the algoritm is identical to that
  // of automorphisms11111().

  K := BaseRing(Parent(f));
  I := Matrix(2,[K|1,0,0,1]);
  
  r := [a[1] : a in Roots(f)];
  assert #r in {7,8};

  lfts := [];
  
  rootsf := [ [a,1] : a in r ];
  if #rootsf eq 7 then 
    rootsf cat:= [[1,0]]; 
  end if;
  
  ra, rb, rc, rd, re, rf, rg, rh := Explode(rootsf);

  for i,j,k in [1..8] do 
    if #{i,j,k} eq 3 then
      A := rootsf[i];
      B := rootsf[j];
      C := rootsf[k];
      // find r,s,t,u such that (r*x + s)/(t*x + u) sends ra to A, rb to B, rc to C
          
      M := Matrix(3,4,[ra[1]*A[2],ra[2]*A[2],-ra[1]*A[1],-ra[2]*A[1],
                       rb[1]*B[2],rb[2]*B[2],-rb[1]*B[1],-rb[2]*B[1],
                       rc[1]*C[2],rc[2]*C[2],-rc[1]*C[1],-rc[2]*C[1] ]);
      BB := Basis(Nullspace(Transpose(M)))[1];
      r := BB[1];
      s := BB[2];
      t := BB[3];
      u := BB[4];
          
      imaged := [r*rd[1] + s*rd[2], t*rd[1] + u*rd[2]];
      imagee := [r*re[1] + s*re[2], t*re[1] + u*re[2]];
      imagef := [r*rf[1] + s*rf[2], t*rf[1] + u*rf[2]];
      imageg := [r*rg[1] + s*rg[2], t*rg[1] + u*rg[2]];
      imageh := [r*rh[1] + s*rh[2], t*rh[1] + u*rh[2]];

      if imaged[2] ne 0 then imaged := [imaged[1]/imaged[2],1]; else imaged := [K!1,0]; end if;
      if imagee[2] ne 0 then imagee := [imagee[1]/imagee[2],1]; else imagee := [K!1,0]; end if;
      if imagef[2] ne 0 then imagef := [imagef[1]/imagef[2],1]; else imagef := [K!1,0]; end if;
      if imageg[2] ne 0 then imageg := [imageg[1]/imageg[2],1]; else imageg := [K!1,0]; end if;
      if imageh[2] ne 0 then imageh := [imageh[1]/imageh[2],1]; else imageh := [K!1,0]; end if;
      if imaged in rootsf and imagee in rootsf and imagef in rootsf and imageg in rootsf and imageh in rootsf then lfts cat:= [[r,s,t,u]]; end if;
    end if;
  end for;

  return Sort([PGLreduce(Matrix(2,z)) : z in lfts]);
end function;


/*
================================================================================
Functions for producing orbit representatives for Sym^8.
================================================================================
*/


function genusthree1x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (1,1,1,1,1,1,1,1), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type 
  //        (1,1,1,1,1,1,1,1),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives, of 1 over the size of the
  // automorphism group of the representative should be equal to 
  // (q-2)*(q-3)*(q-4)*(q-5)*(q-6)/40320. We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  // We normalize our collection of six points by assuming one is at oo, one
  // is at 0, and the sum of the others is 1. Every collection of eight rational
  // points in P^1 can be put in such a form in at least one way, with one
  // exception: when the eight points are the eight elements of P^1(F_7). We 
  // handle that case separately.
  
  // [Proof sketch: If there is a octuple that does not have a representative
  // of this form, write it as oo, 0, 1, x, y, z, w, -1-x-y-z-w. Shifting by 1
  // gives the octuple oo, -1, 0, x-1, y-1, z-1, w-1, -2-x-y-z-w, and we see 
  // that 7 = 0, so we are in characteristic 7. Then, applying the condition to
  // all equivalent sextuples that include 0 and oo, we get a system of 7
  // equations in our 4 variables. Magma verifies that the ideal generated by
  // these equations is trivial.]
  
  // To choose which of these normalized forms to use, we use the one where the
  // ordered set of points other than 0 and oo comes first in some total 
  // ordering.

  // So: Loop a1 < a2 < ... < a5 and set a6 = 1 - a1 - a2 - a3 - a4 - a5.
  // Demand that a5 < a6.
  //
  // In turn, shift each a_i to 0 and rescale so that the sum of the finite 
  // points is again 1. Demand that our original sextuple [a1,...,a6] be smaller
  // than these new sextuples.
  //
  // In turn, move each a_i to infinity, and repeat same loop as above, and
  // again demand that our original [a1,...,a6] is the smallest.

  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  if q lt 7 then return []; end if;

  R<x>:=PolynomialRing(K);
  I := Matrix(2,[K|1,0,0,1]);

  checksum := 0;
  sortKstar := Sort([a : a in K | a ne 0]);
  
  for i1 in [1..q-6] do
    a1 := sortKstar[i1];
    for i2 in [i1+1..q-5] do
      a2 := sortKstar[i2];
      for i3 in [i2+1..q-4] do
        a3 := sortKstar[i3];
        for i4 in [i3+1..q-3] do
          a4 := sortKstar[i4];
          for i5 in [i4+1..q-2] do
            a5 := sortKstar[i5];
            a6 := 1 - a1 - a2 - a3 - a4 - a5;
            if a5 ge a6 then continue i5; end if;
            
            auts := false;
            
            basecase := Sort([a1,a2,a3,a4,a5,a6]);
            
            for i in [1..6] do
              if 1 ne 7*basecase[i] then
                s := 1/(1-7*basecase[i]);
                newcase := Sort([-basecase[i]*s] cat [(basecase[j]-basecase[i])*s : j in [1..6] | j ne i]);
                if newcase lt basecase then continue i5; end if;
                if newcase eq basecase then auts:= true; end if;
              end if;
            end for;
            
            // Put 0 at oo.
           
            newbase := [1/basecase[i] : i in [1..6]];
              
            sum := &+newbase;
            if sum ne 0 then
              s := 1/sum;
              newcase := Sort([a*s : a in newbase]);
              if newcase lt basecase then continue i5; end if;
              if newcase eq basecase then auts:= true; end if;
            end if;
              
            for j in [1..6] do
              if sum ne 7*newbase[j] then
                s := 1/(sum-7*newbase[j]);
                newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..6] | k ne j]);
                if newcase lt basecase then continue i5; end if;
                if newcase eq basecase then auts:= true; end if;
              end if;
            end for;

            for i in [1..6] do
              // send ai to oo and oo to 0... x --> 1/(x-ai)
              newbase := [-1/basecase[i]] cat [1/(basecase[j]-basecase[i]) : j in [1..6] | j ne i];
              
              sum := &+newbase;
              if sum ne 0 then
                s := 1/sum;
                newcase := Sort([a*s : a in newbase]);
                if newcase lt basecase then continue i5; end if;
                if newcase eq basecase then auts:= true; end if;
              end if;
              
              for j in [1..6] do
                if sum ne 7*newbase[j] then
                  s := 1/(sum-7*newbase[j]);
                  newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..6] | k ne j]);
                  if newcase lt basecase then continue i5; end if;
                  if newcase eq basecase then auts:= true; end if;
                end if;
              end for;
            end for;
              
            // We got one!
              
            f := x*(x-a1)*(x-a2)*(x-a3)*(x-a4)*(x-a5)*(x-a6);
            if auts then
              autgroup := automorphisms11111111(f);
            else
              autgroup := [I];
            end if;
   
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum +:= 1/C[2]; 
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;

          end for;
        end for;
      end for;
    end for;
  end for;
  
  if 0 eq q mod 7 then
    f := x^7 - x;
    autgroup := automorphisms11111111(f);
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      checksum +:= 1/C[2]; 
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end if;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  assert checksum eq (q-2)*(q-3)*(q-4)*(q-5)*(q-6) / 40320;

  
  return Clist;
end function;
  

//------------------------------------------------------------------------------

function genusthree2x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (2,...), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (2,...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (2,1,1,1,1,1,1): q * (q-1) * (q-2) * (q-3) * (q-4) / 1440
  // Galois type (2,2,1,1,1,1):   q * (q+1) * (q-1) * (q-2)^2 / 192
  // Galois type (2,2,2,1,1):     q * (q+1) * (q-2) * (q^2-q-4) / 96
  // Galois type (2,2,2,2):       (q+2) * (q-2) * (q-3) * (q^2-q -4) / 384

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.

  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);
  I := Matrix(2,[K|1,0,0,1]);


  // Galois type (2,1,1,1,1,1,1):
  checksum2111111 := 0;

  squares := [a : a in {b^2 : b in K} | a ne 0];
  // The irreducible quadratics:
  irreduciblequadratics := [(x+a)^2 - ns*b : a in K, b in squares];

  // We will obtain PGL(2,K) orbit representatives for six rational points,
  // using the technique we used in the function genustwo1x in the file
  // Hyperelliptic2.magma. We don't use that function itself, because it
  // would return O(q^3) values, and we want our memory requirements to be
  // less than that.
  
  // For more details, see the comments to genustwo1x. Basically, we normalize
  // by assuming a point at oo, a point at 0, and the sum of the other four
  // points is 1. Every collections of six points can be moved by PGL(2,K) to
  // such a normalized form, unless q is a power of 5 and the six points are
  // the points of P^1(F_5). We deal with this case at the end.


  sortKstar := Sort([a : a in K | a ne 0]);

  for i1 in [1..q-4] do
    a1 := sortKstar[i1];
    for i2 in [i1+1..q-3] do
      a2 := sortKstar[i2];
      for i3 in [i2+1..q-2] do
        a3 := sortKstar[i3];
        a4 := 1 - a1 - a2 - a3;
        if a3 ge a4 then continue i3; end if;
            
        auts := false;
            
        basecase := Sort([a1,a2,a3,a4]);
            
        for i in [1..4] do
          if 1 ne 5*basecase[i] then
            s := 1/(1-5*basecase[i]);
            newcase := Sort([-basecase[i]*s] cat [(basecase[j]-basecase[i])*s : j in [1..4] | j ne i]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
        end for;
            
        // Put 0 at oo.
           
        newbase := [1/basecase[i] : i in [1..4]];

        sum := &+newbase;
        if sum ne 0 then
          s := 1/sum;
          newcase := Sort([a*s : a in newbase]);
          if newcase lt basecase then continue i3; end if;
          if newcase eq basecase then auts:= true; end if;
        end if;
              
        for j in [1..4] do
          if sum ne 5*newbase[j] then
            s := 1/(sum-5*newbase[j]);
            newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..4] | k ne j]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
        end for;

        for i in [1..4] do
          // send ai to oo and oo to 0... x --> 1/(x-ai)
          newbase := [-1/basecase[i]] cat [1/(basecase[j]-basecase[i]) : j in [1..4] | j ne i];
          
          sum := &+newbase;
          if sum ne 0 then
            s := 1/sum;
            newcase := Sort([a*s : a in newbase]);
            if newcase lt basecase then continue i3; end if;
            if newcase eq basecase then auts:= true; end if;
          end if;
              
          for j in [1..4] do
            if sum ne 5*newbase[j] then
              s := 1/(sum-5*newbase[j]);
              newcase := Sort([-newbase[j]*s] cat [(newbase[k]-newbase[j])*s : k in [1..4] | k ne j]);
              if newcase lt basecase then continue i3; end if;
              if newcase eq basecase then auts:= true; end if;
            end if;
          end for;
        end for;
              
        // We got one!
              
        aa := a2/a1;
        bb := a3/a1;
        cc := a4/a1;
        splitpart := x*(x-1)*(x-aa)*(x-bb)*(x-cc);
        if auts then
          autgroupsplitpart := automorphisms111111(aa,bb,cc);
        else
          autgroupsplitpart := [I];
        end if;
        
        // Now tack on an irreducible quadratic factor. If the automorphism
        // group of the split part if trivial, we run through all such 
        // quadratics. Otherwise, we run through representatives of the
        // automorphism group acting on such quadratics.
        
        if not auts then
          autgroup := [I];
          checksum2111111 +:= #irreduciblequadratics; 

          for quadratic in irreduciblequadratics do
            f := quadratic*splitpart;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;

        else
          // Nontrivial automorphisms of the split part.
          for quadratic in irreduciblequadratics do
            autgroup := [];
            for M in autgroupsplitpart do
              newquad := Numerator(Evaluate(quadratic,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])));
              newquad := newquad/Coefficient(newquad,2);
              if newquad lt quadratic then
                continue quadratic;
              end if;
              if newquad eq quadratic then
                autgroup cat:= [M];
              end if;
            end for;
            
            // If we are still here, we have a good quadratic, and we know
            // the automorphism group.

            f := quadratic*splitpart;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum2111111 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
      end for;
    end for;
  end for;
  
  // The case we miss with the given normalization:
  
  if 0 eq q mod 5 then
    splitpart := x^5 - x;
    autgroupsplitpart := automorphisms111111(K!2,K!3,K!4);

    for quadratic in irreduciblequadratics do
      autgroup := [];
      for M in autgroupsplitpart do
        newquad := Numerator(Evaluate(quadratic,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])));
        newquad := newquad/Coefficient(newquad,2);
        if newquad lt quadratic then
          continue quadratic;
        end if;
        if newquad eq quadratic then
          autgroup cat:= [M];
        end if;
      end for;
            
      // If we are still here, we have a good quadratic, and we know
      // the automorphism group.

      f := quadratic*splitpart;

      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        checksum2111111 +:= 1/C[2];
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end if;

  assert checksum2111111  eq q * (q-1) * (q-2) * (q-3) * (q-4)/ 1440;


  // Galois type (2,2,1,1,1,1):
  checksum221111 := 0;
  
  // We get pairs of irreducible quadratics with their automorphism groups
  // normalized. Then we loop through automorphisms groups A, compute orbit
  // reps for A acting on split quartics, and for each rep take the rep and
  // multiply it by the pairs of quadratics with that automorphism group.

  q := #K;
  R<x>:=PolynomialRing(K);

  twoquadratics := fourpoints22(K);  

  groups22 := {m[3] : m in twoquadratics};
  groups22 := [G : G in groups22];
  
  linears := [1] cat [x-a : a in K];

  for A in groups22 do
    twoquadraticsA := [g[1] : g in twoquadratics | g[3] eq A];
 
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^4 : M in shortA];

    
    for i1 in [1..#linears-3] do
      for i2 in [i1+1..#linears-2] do
        part2 := linears[i1]*linears[i2];
        for i3 in [i2+1..#linears-1] do
          part3 := part2*linears[i3];
          for i4 in [i3+1..#linears] do
            splitpart := part3*linears[i4];
            

            autgroup := [I];
            for i in [1..#shortA] do
              newquartic := Numerator(Evaluate(splitpart,rats[i]) * mults[i]);
              newquartic := newquartic/Coefficient(newquartic,Degree(newquartic));
              if newquartic lt splitpart then continue i4; end if;
              if newquartic eq splitpart then autgroup cat:= [shortA[i]]; end if;
            end for;

            // If we are here, we have a good one!
            checksum221111 +:= #twoquadraticsA/#autgroup;
            
            for quads in twoquadraticsA do
              f := quads*splitpart;

              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
              
            end for;
          end for;
        end for;
      end for;
    end for;
  end for;

  assert checksum221111 eq q * (q+1) * (q-1) * (q-2)^2 / 192;

  // Now, Galois type (2,2,2,1,1).
  checksum22211 := 0;
  
  // We use the algorithm used in the function genustwo222 from the file
  // Hyperelliptic2.magma to create PGL(2,K) orbit representatives of products
  // of three distinct irreducible quadratics, and then multiply them by all
  // products of two linear polynomials (up to the automorphism group of the
  // product of three quadratics).

  twolinears := [a*b : a, b in linears | a lt b];

  factoredquadratics := [<[a[1] : a in Factorization(f[1])],f[2],f[3]> : f in twoquadratics];

  // Create a list of examples that we will need to consider in further
  // detail at the end. These will be products of three quadratics, such that
  // the mu-invariants of all pairs of quadratics are equal.
  
  trickyones := AssociativeArray();

  autgroups := Sort([a : a in {m[3] : m in factoredquadratics}]);

  for A in autgroups do
    // Compute representatives for the irreducible quadratics under the
    // action of A. Then run through the products of each one with the
    // elements of fproducts with automorphism group A.
    
    // Make a list of the pairs of quadratics with automorphism group A:
    
    factoredquadraticsA := [ <a[1], mu_invariant(a[1][1],a[1][2])> : a in factoredquadratics | a[3] eq A];
    
    // To make the computation of orbits representatives of A acting on
    // quadratics more efficient, we precompute some expressions.
    shortA := [M : M in A | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortA];
    mults := [(M[2,1]*x + M[2,2])^2 : M in shortA];

    for a,b in K do
      quadratic := x^2 + a*x + b;
      D := Discriminant(quadratic);
      if IsSquare(D) then continue b; end if;

      autgroup222 := [I];
      for i in [1..#shortA] do
        g := Numerator(Evaluate(quadratic,rats[i]) * mults[i]);
        g := g/Coefficient(g,Degree(g));
        if g lt quadratic then continue b; end if;
        if g eq quadratic then
          autgroup222 cat:= [shortA[i]];
        end if;
      end for;
      
      // OK, we've got a good quadratic. Let's pair it with all the elements
      // of  factoredquadraticsA.

      for quadpair in factoredquadraticsA do
        q1, q2 := Explode(quadpair[1]);
        mu12 := quadpair[2];
        
        if quadratic in [q1,q2] then continue quadpair; end if;
        
        mu13 := mu_invariant(q1,quadratic);
        mu23 := mu_invariant(q2,quadratic);
       
        keepit := false;
        case #{mu12,mu13,mu23}:
          when 3:
            if mu12 eq Sort([mu12,mu13,mu23])[1] then
              keepit := true;
            end if;

          when 2:
            if mu13 eq mu23 then
              keepit := true;
            end if;

          when 1:
            // The trickiest case. Postpone analysis.
            if mu12 in Keys(trickyones) then
              trickyones[mu12] cat:= [<q1,q2,quadratic>];
            else
              trickyones[mu12] := [<q1,q2,quadratic>];
            end if;
        end case;
            
        if keepit then
          // We have one!
          threequadratics := q1*q2*quadratic;

          if #autgroup222 eq 1 then
            checksum22211 +:= #twolinears;
            autgroup := [I];
            for splitpart in twolinears do
              f := threequadratics*splitpart;

              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;

          else
            // We have nontrivial automorphisms.

            for splitpart in twolinears do
              autgroup := [];
              for M in autgroup222 do
                newquad := Numerator(Evaluate(splitpart,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])) * (M[2,1]*x + M[2,2])^2);
                newquad := newquad/Coefficient(newquad,Degree(newquad));
                if newquad lt splitpart then
                  continue splitpart;
                end if;
                if newquad eq splitpart then
                  autgroup cat:= [M];
                end if;
              end for;
            
              // If we are still here, we have a good quadratic, and we know
              // the automorphism group.

              f := threequadratics*splitpart;

              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                checksum22211 +:= 1/C[2];
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;
          end if;
        end if;
      end for;
    end for;
  end for;


  // OK. Now we are left with the tricky ones.
  
  for mu in Keys(trickyones) do
    taken := [];
    for t in trickyones[mu] do
      threequadratics := t[1]*t[2]*t[3];
      move := Set(mapsbetweenpairsofquadratics([t[1],t[2]],[t[1],t[2]])
                  cat 
                  mapsbetweenpairsofquadratics([t[1],t[2]],[t[1],t[3]])
                  cat 
                  mapsbetweenpairsofquadratics([t[1],t[2]],[t[2],t[3]]));
      images := {};
      for M in move do
        g := Numerator(Evaluate(threequadratics,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])));
        g := g/Coefficient(g,6);
        images join:= {g};
      end for;
      threequadratics := Min(images);
      if not threequadratics in taken then
        taken cat:= [threequadratics];
        bool, autgroup222 := isomorphisms222(threequadratics,threequadratics);

        if #autgroup222 eq 1 then
          checksum22211 +:= #twolinears;
          autgroup := [I];
          for splitpart in twolinears do
            f := threequadratics*splitpart;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;

        else
          // We have nontrivial automorphisms.

          for splitpart in twolinears do
            autgroup := [];
            for M in autgroup222 do
              newquad := Numerator(Evaluate(splitpart,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])) * (M[2,1]*x + M[2,2])^2);
              newquad := newquad/Coefficient(newquad,Degree(newquad));
              if newquad lt splitpart then
                continue splitpart;
              end if;
              if newquad eq splitpart then
                autgroup cat:= [M];
              end if;
            end for;
            
            // If we are still here, we have a good quadratic, and we know
            // the automorphism group.

            f := threequadratics*splitpart;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum22211 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
      end if;
    end for;
  end for;

  assert checksum22211 eq q * (q+1) * (q-2) * (q^2 - q - 4)/96;
  
  // Galois type (2,2,2,2):
  checksum2222 := 0;
  L := ext<K|2>;
  
  // we have twoquadratics and factoredquadratics and irreduciblequadratics
  
  for quartic1 in factoredquadratics do
    P1, Q1 := Explode(quartic1[1]);
    muP1Q1 := mu_invariant(P1,Q1);

    alpha1 := Roots(P1,L)[1][1];
    alpha2 := alpha1^q;
    alpha3 := Roots(Q1,L)[1][1];
    M1 := Matrix(2,[alpha1*(alpha3-alpha2), alpha2*(alpha1-alpha3), (alpha3-alpha2), (alpha1-alpha3)]);
    // Sends oo to alpha1, 0 to alpha2, 1 to alpha3.
    M1inv := M1^-1;
    
    // To make some computation more efficient, we precompute some expressions.
    shortauts := [M : M in quartic1[3] | M ne I];
    rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortauts];
    
    drawfrom := [];
    for P in irreduciblequadratics do
      if P ne P1 and P ne Q1 then
        muP1P := mu_invariant(P,P1);
        muQ1P := mu_invariant(P,Q1);
        if muP1Q1 le muP1P and muP1Q1 le muQ1P then
          drawfrom cat:= [ <P, muP1P, muQ1P> ];
        end if;
      end if;
    end for;
    
    for iP in [1..#drawfrom-1] do
      quadP := drawfrom[iP];
      P2 := quadP[1];
      
      muP1P2 := quadP[2];
      muQ1P2 := quadP[3];

      equalitycount1 := 1;

      if muP1P2 eq muP1Q1 then 
        equalitycount1 +:=1;
      end if;
      
      if muQ1P2 eq muP1Q1 then 
        equalitycount1 +:=1;
      end if;

      for iQ in [iP+1..#drawfrom] do
        quadQ := drawfrom[iQ];
        Q2 := quadQ[1];
        muP2Q2 := mu_invariant(P2,Q2);

        if muP1Q1 le muP2Q2 then
          equalitycount2 := equalitycount1;
          if muP1Q1 eq muP2Q2 then 
            equalitycount2 +:=1;
          end if;

          muP1Q2 := quadQ[2];
          muQ1Q2 := quadQ[3];

          muP1Q2 := quadQ[2];
          if muP1Q1 eq muP1Q2 then 
            equalitycount2 +:=1;
          end if;
      
          muQ1Q2 := quadQ[3];
          if muP1Q1 eq muQ1Q2 then 
            equalitycount2 +:=1;
          end if;

          // OK. Here we are. muP1Q1 is the smallest, but there may be
          // other pairs with the same mu value. We want the pair P1Q1 to be
          // distinguished in some way, because then we can just compare 
          // P1*Q1*P2*Q2 to all the octics we get by applying the automorphisms
          // of P1*Q1, which we know. So we describe a procedure that will 
          // almost always specify one quartic factor of a product of four
          // quadratics, based solely on the values of mu. If the procedure
          // succeeds and identifies P1*Q1, we process (P1,Q1,P2,Q2) just with
          // automorphisms of P1*Q1. If the procedure succeeds and identifies
          // a quartic other than P1*Q1, we skip (P1,Q1,P2,Q2) and move on to
          // the next quadruple of quadratics. If the procedure fails, we do
          // a more thorough analysis of (P1,Q1,P2,Q2), where we take every
          // pair of quadratics in our quartet that has the same mu value as
          // P1*Q1, apply all the elements of PGL(2,K) that send the product of
          // that pair to P1*Q1, and see which of the corresponding octics is
          // smallest.
          
          // When we apply the procedure to distinguish a pair of quadratics,
          // we just immediately skip to the next value of Q2 if the procedure
          // distinguishes a pair other than P1, Q1. If the procedure 
          // distinguishes P1, Q1, we set the flag "easycase" to true. If the
          // procedure fails to specify a pair of quadratics, we set the flag
          // to false. Afterwards, we continue to process (P1,Q1,P2,Q2) as the
          // flag specifies.
          
          easycase := false;
          special4 := false; 
          
          case equalitycount2:
            when 1:
              // Go ahead.
               easycase := true;

            when 2:
            
              if muP2Q2 ne muP1Q1 then
                if muP1P2 eq muP1Q1 then nu := muQ1Q2; end if;
                if muP1Q2 eq muP1Q1 then nu := muQ1P2; end if;
                if muQ1P2 eq muP1Q1 then nu := muP1Q2; end if;
                if muQ1Q2 eq muP1Q1 then nu := muP1P2; end if;
                
                if nu lt muP2Q2 then continue iQ; end if;
                easycase := (muP2Q2 lt nu);
                
              else
                if #{muP1P2, muP1Q2, muQ1P2, muQ1Q2} eq 4 then
                  nu := Min([muP1P2, muP1Q2, muQ1P2, muQ1Q2]);
                  case nu:
                    when muP1P2:
                      if muQ1P2 lt muP1Q2 then continue iQ; end if;
                    when muP1Q2:
                      if muQ1Q2 lt muP1P2 then continue iQ; end if;
                    when muQ1P2:
                      if muP1P2 lt muQ1Q2 then continue iQ; end if;
                    when muQ1Q2:
                      if muP1Q2 lt muQ1P2 then continue iQ; end if;
                  end case;
                  easycase := true;
                else
                  easycase := false;
                end if;
              end if;
                
            when 3:
              if muP2Q2 eq muP1Q1 then continue iQ; end if;
              if (#{muP1Q1, muP1P2, muQ1Q2} eq 1) or (#{muP1Q1, muP1Q2, muQ1P2} eq 1) then
                easycase := true;
              else
                easycase := false;
              end if;

            when 4:
              if muP2Q2 eq muP1Q1 then
                if (muP1P2 eq muQ1Q2) or (muP1Q2 eq muQ1P2) then
                  easycase := false;
                else
                  continue iQ;
                end if;
              else
                mu := Max([muP1P2, muP1Q2, muQ1Q2, muQ1P2]);
                if mu lt muP2Q2 then continue iQ; end if;
                easycase := (mu gt muP2Q2);
                special4 := true;
              end if;

            when 5:
              if muP2Q2 eq muP1Q1 then continue iQ; end if;
              easycase := true;
              
            when 6:
              easycase := false;

          end case;
              
          if easycase then
            f := P1*Q1*P2*Q2;
            autgroup := [I];
            for i in [1..#shortauts] do
              g := Numerator(Evaluate(f,rats[i]));
              g := g/Coefficient(g,8);
              if g lt f then continue iQ; end if;
              if g eq f then autgroup cat:= [shortauts[i]]; end if;
            end for;
              
            // We've got one. 
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum2222 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;

          else

            // We need a more thorough analysis.
            // We find all elements Gamma of PGL that send one of the quartic
            // factors of f := P1*Q1*P2*Q2 to P1*Q1, look at the images 
            // Gamma(f), and accept f if it is the smallest.
  
            // First, the (nontrivial) elements that send P1*Q1 to itself.

            f := P1*Q1*P2*Q2;
            autgroup := [I];
            for i in [1..#shortauts] do
              g := Numerator(Evaluate(f,rats[i]));
              g := g/Coefficient(g,8);
              if g lt f then continue iQ; end if;
              if g eq f then autgroup cat:= [shortauts[i]]; end if;
            end for;
            
            // Now the other quartic factors. We only look at some of them
            // if the flag "special4" is true.
            quadpairs := [];
            if not special4 then
              if muP1P2 eq muP1Q1 then quadpairs cat:= [[P1,P2]]; end if;
              if muP1Q2 eq muP1Q1 then quadpairs cat:= [[P1,Q2]]; end if;
              if muQ1P2 eq muP1Q1 then quadpairs cat:= [[Q1,P2]]; end if;
              if muQ1Q2 eq muP1Q1 then quadpairs cat:= [[Q1,Q2]]; end if;
              if muP2Q2 eq muP1Q1 then quadpairs cat:= [[P2,Q2]]; end if;
            else
              if muQ1Q2 ne muP1Q1 then quadpairs cat:= [[P1,P2]]; end if;
              if muQ1P2 ne muP1Q1 then quadpairs cat:= [[P1,Q2]]; end if;
              if muP1Q2 ne muP1Q1 then quadpairs cat:= [[Q1,P2]]; end if;
              if muP1P2 ne muP1Q1 then quadpairs cat:= [[Q1,Q2]]; end if;
            end if;
            for pair in quadpairs do
              P, Q := Explode(pair);
              for i in [1..2] do
                beta1, beta2 := Explode([a[1] : a in Roots(P,L)]);
                for j in [1..2] do
                  for beta3 in [a[1] : a in Roots(Q,L)] do
                    M2 := Matrix(2,[beta1*(beta3-beta2), beta2*(beta1-beta3), (beta3-beta2), (beta1-beta3)]);
                    M3 := PGLreduce(M2*M1inv);
                    if &and[z in K : z in Eltseq(M3)] then
                      M := Matrix(2,[K!z : z in Eltseq(M3)]);
                      // M takes alpha1 to beta1, alpha2 to beta2, alpha3 to beta3.
                      // So it takes the quadratics in pair to P1 and Q1.
                      ff := Numerator(Evaluate(f,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2])));
                      ff := ff/Coefficient(ff,8);
                      assert 0 eq ff mod (P1*Q1);
                
                      if ff lt f then continue iQ; end if;
                      if ff eq f then autgroup cat:=[M]; end if;
                    end if;
                  end for;
                  beta1, beta2 := Explode([beta2,beta1]);
                end for;
                P,Q := Explode([Q,P]);
              end for;
            end for;

            // We've got one. 
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              checksum2222 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end if;
        end if;
      end for;
    end for;
  end for;
  
  assert checksum2222 eq (q + 2) * (q - 2) * (q - 3) * (q^2 - q - 4)/384;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;

//------------------------------------------------------------------------------



function genusthree3x(K : passback := true, curves := true, output := false, outputfile := "", skip3221 := false)
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (3,...), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (3,...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // If skip3221 = true, we skip the Galois type (3,2,2,1). This is helpful
  // when computing all genus-3 hyperelliptic curves, because genusthree71 runs
  // faster if we allow it to include this Galois type in its computation.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (3,3,2):       q * (q-1) * (q^3-q-3) / 36
  // Galois type (3,3,1,1):     q * (q+1) * (q^3-q-3) / 36;
  // Galois type (3,2,2,1):     q * (q+1)^2 * (q-1) * (q-2) / 24;
  // Galois type (3,2,1,1,1):   q^2 * (q-1)^2 * (q+1) / 36;
  // Galois type (3,1,1,1,1,1): q * (q+1) * (q-1) * (q-2) * (q-3) / 360;

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);
  I := Matrix(2,[K|1,0,0,1]);
  quadratics := [x-a : a in K] cat [x^2 + a*x + b : a,b in K | a^2 ne 4*b];
  irreduciblequads := [x^2 + a*x + b : a,b in K | not IsSquare(a^2-4*b)];
  linears := [1] cat [x-a : a in K];
  basecubic := irreducible3(K);

  // Elements of PGL that fix our base cubic.
  A1 := I;
  A2 := Matrix(2,[K|0,-1,1,-1]);
  A3 := Matrix(2,[K|1,-1,1,0]);
  
  // Galois types (3,3,2) and (3,3,1,1):
  // We cut and paste the code from genustwo3x(), but insert an inner loop
  // after a polynomial g of Galois type (3,3) is obtained, and multiply g
  // by all possible separable quadratics, up to the automorphism group of g. 
  
  checksum33 := 0;

  // Involution with rational fixed points:
  B1 := Matrix(2,[K|-1,0,0,1]);      
  // Another involution with rational fixed points.
  // This one, together with the As, gives a copy of S3.
  B1prime := Matrix(2,[K|-1,1,0,1]); 

  // Want a value of b such that -(bb^2 + bb + 1) is nonsquare.
  // These do not exist in characteristic 3 (and the need for them will 
  // never arise in this case) so we will use a dummy value. Also, we will
  // choose bb from the prime field when possible.
  // In characteristic 3 we will still need a standard involution with no
  // fixed points (which is part of the role that B2 plays in other
  // characteristics) but we have more freedom in our choice.
  p,e := Explode(Factorization(q)[1]);
  if p eq 3 then 
    bb := K!0;
    B2 := Matrix(2,[0,ns,1,0]);
    B2disc := ns;
  else
    if IsOdd(e) then
      bb := K!0;
      repeat bb+:=1; until not IsSquare(bb^2+bb+1);
    else
      g := PrimitiveElement(K);
      bb := K!1;
      repeat bb*:=g; until not IsSquare(bb^2+bb+1);
    end if;
    // So here is an involution without rational fixed points, that, together
    // with the As, gives a copy of S3.
    B2 := Matrix(2,[1,bb,bb+1,-1]);
    B2disc := 1+bb+bb^2;
  end if;

  // What are the possible automorphism groups we will get?
  
  // 1. Trivial
  autgroup1 := [I];
  
  // 2. Order 2, rational fixed points.
  autgroup2rat := [I, B1];
  
  // 3. Order 2, irrational fixed points.
  autgroup2irrat := [I,B2];
  
  // 4. Order 3.
  autgroup3 := [A1, A2, A3];
  
  // 5. S3 with involutions with rational fixed points.
  autgroupS3rat := [A1, A2, A3] cat [PGLreduce(B1prime*A) : A in [A1,A2,A3]];
  
  // 6. S3 with involutions with irrational fixed points.
  autgroupS3irrat := [A1, A2, A3] cat [PGLreduce(B2*A) : A in [A1,A2,A3]];
  
  // 7. Cyclic of order 6, *only in characteristic different from 3*
  M := Matrix(2,[K|1,-2,2,-1]);
  autgroup6 := [A1, A2, A3] cat [PGLreduce(M*A) : A in [A1,A2,A3]];
  
  // For each possible automorphism group G, we want a set of unique
  // representatives for the action of G on separable homogeneous polynomials
  // of degree 2.
  
  quadratics1       := [<f, autgroup1> : f in quadratics];
  quadratics2rat    := [];
  quadratics2irrat  := [];
  quadratics3       := [];
  quadraticsS3rat   := [];
  quadraticsS3irrat := [];
  quadratics6       := [];
  
  for quad in quadratics do

    // Representatives for order 2 with rational fixed points:
    smallest := quad;
    stab := [];
    for M in autgroup2rat do
      f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                     * (M[2,1]*x + M[2,2])^2);
      f := f/Coefficient(f,Degree(f));
      if f lt smallest then smallest := f; end if;
      if f eq quad then stab cat:= [M]; end if;
    end for;
    if quad eq smallest then
      quadratics2rat cat:= [<quad,stab>];
    end if;
      
    // Representatives for order 2 with irrational fixed points:
    smallest := quad;
    stab := [];
    for M in autgroup2irrat do
      f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                     * (M[2,1]*x + M[2,2])^2);
      f := f/Coefficient(f,Degree(f));
      if f lt smallest then smallest := f; end if;
      if f eq quad then stab cat:= [M]; end if;
    end for;
    if quad eq smallest then
      quadratics2irrat cat:= [<quad,stab>];
    end if;
      
    // Representatives for order 3:
    smallest := quad;
    stab := [];
    for M in autgroup3 do
      f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                     * (M[2,1]*x + M[2,2])^2);
      f := f/Coefficient(f,Degree(f));
      if f lt smallest then smallest := f; end if;
      if f eq quad then stab cat:= [M]; end if;
    end for;
    if quad eq smallest then
      quadratics3 cat:= [<quad,stab>];
    end if;
      
    // Representatives for S3 with rational fixed points:
    smallest := quad;
    stab := [];
    for M in autgroupS3rat do
      f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                     * (M[2,1]*x + M[2,2])^2);
      f := f/Coefficient(f,Degree(f));
      if f lt smallest then smallest := f; end if;
      if f eq quad then stab cat:= [M]; end if;
    end for;
    if quad eq smallest then
      quadraticsS3rat cat:= [<quad,stab>];
    end if;
      
    // Representatives for S3 with irrational fixed points:
    smallest := quad;
    stab := [];
    for M in autgroupS3irrat do
      f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                     * (M[2,1]*x + M[2,2])^2);
      f := f/Coefficient(f,Degree(f));
      if f lt smallest then smallest := f; end if;
      if f eq quad then stab cat:= [M]; end if;
    end for;
    if quad eq smallest then
      quadraticsS3irrat cat:= [<quad,stab>];
    end if;
      
    // Representatives for order 6:
    if 0 ne q mod 3 then
      smallest := quad;
      stab := [];
      for M in autgroup6 do
        f := Numerator(Evaluate(quad,(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]))
                       * (M[2,1]*x + M[2,2])^2);
        f := f/Coefficient(f,Degree(f));
        if f lt smallest then smallest := f; end if;
        if f eq quad then stab cat:= [M]; end if;
      end for;
      if quad eq smallest then
        quadratics6 cat:= [<quad,stab>];
      end if;
    end if;

  end for;

  
  // First will look at trace-1 matrices with a + b - c - 1 and a + b - c nonzero.
  // These are exactly the ones that gives sets with no involutions.

  for b in K do 
    if b le -b then
      flagb := (b eq -b);
      for c in K do
        if b le c and b le -c then
          flagc1 := (b eq c);
          flagc2 := (b eq -c);
          bada1 := c-b;
          bada2 := c-b+1;
          for a in K do
            if a ne bada1 and a ne bada2 and b le 2*a + b - c - 1 and b le -2*a - b + c + 1 then
              // Check that determinant is nonzero and that we aren't taking the 
              // base cubic to itself.
              d := 1-a;
              det := a*d-b*c;
              
              if det ne 0 and (a ne d or b ne 0 or c ne 0) and [a,b,c,d] ne [1,-1,1,0] and [a,b,c,d] ne [0,1,-1,1] then
                 // Check that determinant is correct.
              
                n1 := (b - c - d)^2;
                n2 := (a + b - c)^2;

                invdet := 1/(a*d-b*c);              
                if n1 eq n2 or (invdet lt n1*invdet and invdet lt n2*invdet) then

                  // In characteristic 3, there is a 2-parameter family of M
                  // such that the 3 determinants are equal.
                  // [a, b; a+b+1, 1-a].
                  // So we want to check that [b,c] is smallest of the corresponding
                  // pairs of elements of the partner matrices.

                  if c eq a+b+1 and 0 eq q mod 3 then
                    equivalentM := [
                                     [      b    ,  a + b + 1 ],
                                     [      b + 1,  a + b     ],
                                     [      b - 1,  a + b - 1 ],
                                     [     -b    , -a - b - 1 ],
                                     [     -b + 1, -a - b + 1 ],
                                     [     -b - 1, -a - b     ],
                                     [  a        ,     -b + 1 ],
                                     [  a     + 1,     -b     ],
                                     [  a     - 1,     -b - 1 ],
                                     [  a + b    ,  a     - 1 ],
                                     [  a + b + 1,  a     + 1 ],
                                     [  a + b - 1,  a         ],
                                     [ -a        ,      b - 1 ],
                                     [ -a     + 1,      b + 1 ],
                                     [ -a     - 1,      b     ],
                                     [ -a - b    , -a     + 1 ],
                                     [ -a - b + 1, -a         ],
                                     [ -a - b - 1, -a     - 1 ]
                                   ];
                    if not [b,c] eq Sort(equivalentM)[1] then continue a; end if;                                   
                  end if;

                  flaga1 := (b eq  2*a + b - c - 1);
                  flaga2 := (b eq -2*a - b + c + 1);
              
                  // Do we need further checks for whether we have a distinguished M?
                  if flagb then
                    // compare [b,c,a] to [-b,-c,1-a]
                    if c gt -c or (c eq -c and a gt 1-a) then
                      continue a;
                    end if;
                  end if;
                  if flagc1 then
                    // compare [b,c,a] to [c, 2*a + b - c - 1, a-c]
                    if c gt 2*a + b - c - 1 or (c eq 2*a + b - c - 1 and a gt a - c) then
                      continue a;
                    end if;
                  end if;
                  if flagc2 then
                    // compare [b,c,a] to [-c, -2*a - b + c + 1, -a + c + 1]
                    if c gt -2*a - b + c + 1 or (c eq -2*a - b + c + 1 and a gt -a + c + 1) then
                      continue a;
                    end if;
                  end if;
                  if flaga1 then
                    // compare [b,c,a] to [2*a + b - c - 1, -b, -a - b + 1]
                    if c gt -b or (c eq -b and a gt -a - b + 1) then
                      continue a;
                    end if;
                  end if;
                  if flaga2 then
                    // compare [b,c,a] to [-2*a - b + c + 1, b, a + b]
                    if c gt b or (c eq b and a gt a+b) then
                      continue a;
                    end if;
                  end if;
              
                  // We have a good one! And we know it has no involutions.

                  newcubic := Numerator(Evaluate(basecubic,(-d*x+b)/(c*x-a))*(c*x-a)^3);
                  newcubic := newcubic/Coefficient(newcubic,3);
                  sextic := basecubic*newcubic;

                  // Only elements of PGL2 with nonzero trace that give automorphisms
                  // of order 3 are of the form [c+d, -c, c, d], so condition is that
                  // a = c + d and b + c = 0.
  
                  if (a eq c + d and b + c eq 0) then
                    quadraticreps := quadratics3;
                  else
                    quadraticreps := quadratics1;
                  end if;


                  for deg2 in quadraticreps do
                    f := sextic*deg2[1];
                    autgroup := deg2[2];

                    if curves then
                      Cs := curves_from_divisor(f,autgroup);
                    else
                      Cs := [<f,#autgroup,autgroup>];
                    end if;
  
                    for C in Cs do
                      checksum33 +:= 1/C[2]; 
                      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                      if passback then Clist cat:= [C]; end if;
                    end for;
                  end for;
               end if;
              end if;
            end if;
          end for;
        end if;
      end for;
    end if;
  end for;
  
  // OK. Now the sets that have involutions.
  
  for b, c in K do
    if b*c eq -1 then continue c; end if;
    if c ne 1 then
      newb := c/(1-c);
      newc := (b-c+2)/(1-c);
      if b gt newb or (b eq newb and c gt newc) then continue c; end if;
    end if;
    
    if b ne -1 then
      newb := (c-b-2)/(b+1);
      newc := b/(b+1);
      if b gt newb or (b eq newb and c gt newc) then continue c; end if;
    end if;

    // We have a good one! And we know it has an involution.
    M := Matrix(2,[1,b,c,-1]);

    newcubic := Numerator(Evaluate(basecubic,(x+b)/(c*x-1))*(c*x-1)^3);
    newcubic := newcubic/Coefficient(newcubic,3);
    sextic := basecubic*newcubic;

    sexticauts:= 2;
    if (c eq b+1) or (b eq -2 and c eq 2) then
      // We have automorphisms of order 3 as well.
      sexticauts:= 6;
    end if;  
    
    // Now we want to conjugate everything so that the matrix M becomes one of
    // our standard ones.
    
    disc := -Determinant(M);


    if sexticauts eq 2 then
      // We just need to conjugate the matrix M above to either B1 or B2.
      if IsSquare(disc) then
        s := Sqrt(disc);
        if s eq -1 then s := 1; end if;
        // Conjugate by N = [b, s+1; -s-1, c].
        // This takes M to B1. 
        // det N = 2*(s + b*c + 1) which is nonzero, because if s = -1-b*c
        // and s^2 = 1 + b*c then s^2 + s = 0 and s is 0 or -1. 
        // But s is nonzero by construction, and s is not -1 because we
        // take 1 to be the square root of 1.
        sextic := Numerator(Evaluate(sextic,(b*x + s+1)/(-(s+1)*x + c)));
        sextic := sextic/Coefficient(sextic,6);
        quadraticreps := quadratics2rat;
      else
        s := Sqrt(disc*B2disc);
        if 0 eq q mod 3 then
          // Conjugate by [s,ns; 0, c*ns]. This takes M to B2.
          sextic := Numerator(Evaluate(sextic,(s*x + ns)/(c*ns)));
          sextic := sextic/Coefficient(sextic,6);
        else
          // Conjugate by N = [s + bb^2 + bb + 1, bb*s; c*(bb^2 + bb + 1), 0].
          // Note that N^-1 is [0, -bb*s; -c*(bb^2 + bb + 1), s + bb^2 + bb + 1].
          // This takes M to B2.
          sextic := Numerator(Evaluate(sextic,((s+B2disc)*x + bb*s)/(c*B2disc*x)));
          sextic := sextic/Coefficient(sextic,6);
        end if;
        quadraticreps := quadratics2irrat;
      end if;
    else
      // The automorphism group has order 6. If M is [1,-2;2,-1] then it is
      // commutative, and it's unique among all of our output and we can
      // leave it be. So only make adjustments when c = b + 1.
      if (b eq -2) and (c eq 2) then
        quadraticreps := quadratics6;
      end if;
      if c eq b + 1 then
        if IsSquare(disc) then
          s := Sqrt(disc);
          // Conjugate by N = [s+1, -b-1 ; b+1, s-b], unless characteristic is 3,
          // in which case conjugate by [b, -b-1; b+1, -1].
          // This takes M to B1prime.
          quadraticreps := quadraticsS3rat;
          if 0 eq q mod 3 then
            sextic := Numerator(Evaluate(sextic,(b*x - (b+1))/((b+1)*x - 1)));
          else
            sextic := Numerator(Evaluate(sextic,((s+1)*x - (b+1))/((b+1)*x + (s-b))));
          end if;
          sextic := sextic/Coefficient(sextic,6);
        else
           s := Sqrt(disc*B2disc);
          // Conjugate by N = [s + b*bb + b + 1, bb - b; b - bb, s + b*bb + bb + 1].
          // This takes M to B2.
          quadraticreps := quadraticsS3irrat;
          if b ne bb then
            sextic := Numerator(Evaluate(sextic,((s+b*bb+b+1)*x + (bb-b))/((b-bb)*x + s+b*bb+bb+1)));
            sextic := sextic/Coefficient(sextic,6);
          end if;
        end if;
      end if;
    end if;
    
    for deg2 in quadraticreps do
      f := sextic*deg2[1];
      autgroup := deg2[2];

      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;
  
      for C in Cs do
        checksum33 +:= 1/C[2]; 
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;

  end for;
  
  assert checksum33 eq q*(q-1)*(q^3-q-3)/36 + q*(q+1)*(q^3-q-3)/36;
  // First term is irreducible quadratic cofactor, second term is two
  // linear cofactors.


  
  // Galois type (3,2,2,1)
  // Start with divisor of type (3,1). Typically, no automorphisms.
  // We skip this Galois type if the flag skip3221 is set.
  
  if not skip3221 then
  
    checksum3221 := 0;
    polys31 := fourpoints31(K);
    autgroup := [I]; // This Galois type always has trivial automorphism group.

    for p31 in polys31 do
      g := p31[1];
      auts := p31[3];
      if #auts eq 1 then
        checksum3221 +:= (#irreduciblequads)*(#irreduciblequads-1)/2;
        for i in [1..#irreduciblequads-1] do
          gg := g*irreduciblequads[i];
          for j in [i+1..#irreduciblequads] do
            f := gg*irreduciblequads[j];
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
        else
        // Our (3,1) divisor has automorphism group of order 3.
        AA1,AA2,AA3 := Explode(auts);
        assert AA1 eq I;
        for i in [1..#irreduciblequads-1] do
          for j in [i+1..#irreduciblequads] do
            h := irreduciblequads[i]*irreduciblequads[j];
            h2 := Numerator(Evaluate(h,(AA2[1,1]*x+AA2[1,2])/(AA2[2,1]*x + AA2[2,2])));
            h2 := h2/Coefficient(h2,4);
            if h gt h2 then continue j; end if;
            h3 := Numerator(Evaluate(h,(AA3[1,1]*x+AA3[1,2])/(AA3[2,1]*x + AA3[2,2])));
            h3 := h3/Coefficient(h3,4);
            if h gt h3 then continue j; end if;
            f := g*h;
          
            if curves then
               Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum3221 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
      end if;
    end for;
    assert checksum3221 eq q * (q+1)^2 * (q-1) * (q-2) / 24;
  end if;
      
  // Galois type (3,2,1,1,1)
  // Start with degree 3. Add on degree 2s, up to automorphisms of the degree 3.
  // Typically no automorphisms, so adding on three rational points is easy.

  checksum32111 := 0;
  
  // There is at most one irreducible quadratic that is fixed by the
  // automorphims of the base cubic, namely: x^2 - x + 1.
  
  special := x^2 - x + 1;
  
  for quad in irreduciblequads do
    if quad ne special then

      quad2 := Numerator(Evaluate(quad,(A2[1,1]*x + A2[1,2])/(A2[2,1]*x + A2[2,2])));
      quad2 := quad2/Coefficient(quad2,2);
      if quad2 lt quad then continue quad; end if;

      quad3 := Numerator(Evaluate(quad,(A3[1,1]*x + A3[1,2])/(A3[2,1]*x + A3[2,2])));
      quad3 := quad3/Coefficient(quad3,2);
      if quad3 lt quad then continue quad; end if;
      
      
      autgroup := [I];
      g := basecubic*quad;
      for i in [1..#linears-2] do
        g2 := g*linears[i];
        for j in [i+1..#linears-1] do
          g3 := g2*linears[j];
          for k in [j+1..#linears] do
            f := g3*linears[k];
            
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum32111 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
            
          end for;
        end for;
      end for;
    else
      g := basecubic*quad;
      for i in [1..#linears-2] do
        for j in [i+1..#linears-1] do
          for k in [j+1..#linears] do
            autgroup := [I];
            h := linears[i]*linears[j]*linears[k];
            h2 := Numerator(Evaluate(h,(A2[1,1]*x+A2[1,2])/(A2[2,1]*x + A2[2,2]))
                            * (A2[2,1]*x + A2[2,2])^3);
            h2 := h2/Coefficient(h2,Degree(h2));
            if h2 lt h then continue k; end if;
            h3 := Numerator(Evaluate(h,(A3[1,1]*x+A3[1,2])/(A3[2,1]*x + A3[2,2]))
                            * (A3[2,1]*x + A3[2,2])^3);
            h3 := h3/Coefficient(h3,Degree(h3));
            if h3 lt h then continue k; end if;
            if h3 eq h then autgroup := [A1,A2,A3]; end if;

            f := g*h;
            
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum32111 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;

          end for;
        end for;
      end for;
    end if;
  end for;

  assert checksum32111 eq q^2 * (q-1)^2 * (q+1) / 36;
            
  
  // Galois type (3,1,1,1,1,1)
  // Order the elements of P^1(K) so that orbits under 1/(1-x) are grouped,
  // with fixed points last. All but at most two orbits have 3 elements;
  // list them in an arbitrary (but fixed) order.
  // If there is only one element of our five that lies in the smallest orbit,
  // demand that it be the first element of the orbit.
  // If there are two elements of our five lying in the smallest orbit, demand
  // that they be the first two in the ornit.
  // If there are three elements of our five lying in the first orbit that
  // occurs, and one from the second smallest orbit, then demand that it is the
  // first element.
  // If there are three elements from the first orbit that occurs, and two from
  // the second orbit, then demand that they be the first two.
  // We get a nontrivial automorphism group exactly when q = 1 mod 3 and our
  // five points include the two roots of 1/(1-x) = x, and the other three 
  // points lie in the same orbit.
  
  checksum311111 := 0;
  // Make the list of elements of P^1(K), represented by homogeneous bivariate
  // linear polynomials which we write as their dehomogenized versions, and 
  // grouped by orbit under the action x --> 1/(1-x).

  linearlist := [1,x,x-1];
  taken := {K|0,1};
  fixed := [];
  for a in K do
    if not a in taken then
      if a eq 1/(1-a) then
        fixed cat:= [a];
      else
        linearlist cat:= [x-a, x-1/(1-a), x-(a-1)/a];
        taken join:= {a, 1/(1-a), (a-1)/a};
      end if;
    end if;
  end for;
  for a in fixed do
    linearlist cat:= [x-a];
  end for;
  
  // When q = 0 mod 3, there is one fixed point, and the orbit groupings near
  // the end linearlist are like this (with elements indicated by their
  // indices in brackets):
  // [q-5]  [q-4]  [q-3]
  // [q-2]  [q-1]  [ q ]
  // [q+1]

  // When q = 1 mod 3, there are two fixed points, and the orbit groupings near
  // the end linearlist are like this (with elements indicated by their
  // indices in brackets):
  // [q-6]  [q-5]  [q-4]
  // [q-3]  [q-2]  [q-1]
  // [ q ]
  // [q+1]

  // When q = 2 mod 3, there are no fixed points, and the orbit groupings near
  // the end linearlist are like this (with elements indicated by their
  // indices in brackets):
  // [q-7]  [q-6]  [q-5]
  // [q-4]  [q-3]  [q-2]
  // [q-1]  [ q ]  [q+1]


    
  // Loop through examples where the smallest orbit occuring among our five 
  // points contains just one of the five points.
  case q mod 3:
    when 0: end1 := q-5; 
    when 1: end1 := q-6;
    when 2: end1 := q-7;
  end case;
  autgroup := [I];
  
  for i1 in [1..end1 by 3] do
    g1 := basecubic*linearlist[i1];
    for i2 in [i1+3..#linearlist-3] do
      g2 := g1*linearlist[i2];
      for i3 in [i2+1..#linearlist-2] do
        g3 := g2*linearlist[i3];
        for i4 in [i3+1..#linearlist-1] do
          g4 := g3*linearlist[i4];
          for i5 in [i4+1..#linearlist] do
            f := g4*linearlist[i5];

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum311111 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
      end for;
    end for;
  end for;
  
  // Loop through examples where the smallest orbit occuring among our five 
  // points contains exactly two of the five points.
  case q mod 3:
    when 0: end1 := q-5; 
    when 1: end1 := q-6;
    when 2: end1 := q-4;
  end case;
  autgroup := [I];
  
  for i1 in [1..end1 by 3] do
    i2 := i1+1;
    g2 := basecubic*linearlist[i1]*linearlist[i2];
    for i3 in [i1+3..#linearlist-2] do
      g3 := g2*linearlist[i3];
      for i4 in [i3+1..#linearlist-1] do
        g4 := g3*linearlist[i4];
        for i5 in [i4+1..#linearlist] do
          f := g4*linearlist[i5];
          
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            checksum311111 +:= 1/C[2];
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
  end for;

  // Loop through examples where the smallest orbit occuring among our five 
  // points contains exactly three of the five points, but the automorphism
  // group of our divisor is trivial (i.e. our last two points are not the
  // two singleton orbits), and the second smallest orbit contains exactly one
  // of our five points.
  case q mod 3:
    when 0: end1 := q-5; end4 := q-2;
    when 1: end1 := q-6; end4 := q-3;
    when 2: end1 := q-7; end4 := q-4;
  end case;
  
  autgroup := [I];
  
  for i1 in [1..end1 by 3] do
    i2 := i1+1;
    i3 := i1+2;
    g3 := basecubic*linearlist[i1]*linearlist[i2]*linearlist[i3];
    for i4 in [i1+3..end4 by 3] do
      g4 := g3*linearlist[i4];
      for i5 in [i4+3..#linearlist] do
        f := g4*linearlist[i5];
        
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;
  
        for C in Cs do
          checksum311111 +:= 1/C[2];
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end for;
  end for;
       
  // Loop through examples where the smallest orbit occuring among our five 
  // points contains exactly three of the five points, and the second smallest
  // orbit contains exactly two of our five points.
  case q mod 3:
    when 0: end1 := q-5; end4 := q-2;
    when 1: end1 := q-6; end4 := q-3;
    when 2: end1 := q-4; end4 := q-1;
  end case;
  
  autgroup := [I];
  
  for i1 in [1..end1 by 3] do
    i2 := i1+1;
    i3 := i1+2;
    g3 := basecubic*linearlist[i1]*linearlist[i2]*linearlist[i3];
    for i4 in [i1+3..end4 by 3] do
      i5 := i4+1;
      f := g3*linearlist[i4]*linearlist[i5];
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;
  
      for C in Cs do
        checksum311111 +:= 1/C[2];
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end for;
       
  // And finally, the examples with nontrivial automorphism group. This only
  // happens when q = 1 mod 3.

  if 1 eq q mod 3 then
    autgroup := [A1,A2,A3];
    g := basecubic*linearlist[q]*linearlist[q+1];
    for i1 in [1..q-3 by 3] do
      i2 := i1+1;
      i3 := i1+2;

      f := g*linearlist[i1]*linearlist[i2]*linearlist[i3];
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;
  
      for C in Cs do
        checksum311111 +:= 1/C[2];
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end if;

  assert checksum311111 eq q * (q+1) * (q-1) * (q-2) * (q-3) / 360;
  
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;

//------------------------------------------------------------------------------

function genusthree4x(K : passback := true, curves := true, output := false, outputfile := "", skip431 := false)
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (4,...), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (4,...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // If skip431 = true, we skip the Galois type (4,3,1). This is helpful
  // when computing all genus-3 hyperelliptic curves, because genusthree71 runs
  // faster if we allow it to include this Galois type in its computation.

  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:
  
  // Galois type (4,4):       q * (q^4-q^2-4) / 32;
  // Galois type (4,3,1):     q^2 * (q+1)^2 * (q-1) / 12;
  // Galois type (4,2,2):     q^2 * (q+1) * (q-1) * (q-2) / 32;
  // Galois type (4,2,1,1):   q^3 * (q+1) * (q-1) / 16;
  // Galois type (4,1,1,1,1): q^2 * (q+1) * (q-1) * (q-2) / 96;

  // We check this at the end.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);
  I := Matrix(2,[K|1,0,0,1]);
  involutionrat := Matrix(2,[K|0,1,1,0]); // involution with rational fixed points.
  involutionirrat := Matrix(2,[0,ns,1,0]);  // involution with irrational fixed points.

  linears := [1] cat [x-a : a in K];

  quartics := fourpoints4(K : ns := ns);
  
  quarticsrat := [a : a in quartics | a[2] eq 2 and involutionrat in a[3]];
  quarticsirrat := [a : a in quartics | a[2] eq 2 and involutionirrat in a[3]];
  special := [a : a in quartics | a[2] eq 4];
  
  assert #quartics eq #quarticsrat + #quarticsirrat + #special;
  // Also, there is just one special element.
  assert #special eq 1;


  
  // Galois type (4,4):
  
  checksum44 := 0;
  
  // Pairing two distinct quartics whose associated involutions have
  // rational fixed points:

  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        M2 := PGLreduce(involutionrat*M);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M
        M2 := PGLreduce(M2*involutionrat);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M*involutionrat
        M2 := PGLreduce(involutionrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M*involutionrat
        // We have a good one. Now use it to make pairs of quartics.
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
        
        newinvolution := PGLreduce(M^-1*involutionrat*M);
        if newinvolution eq involutionrat then
          autgroup := [I,involutionrat];
        else
          autgroup := [I];
        end if;

        for j in [2..#quarticsrat] do
          q2 := Numerator(Evaluate(quarticsrat[j][1],lft));
          q2 := q2/Coefficient(q2,4);
          for i in [1..j-1] do
            q1 := quarticsrat[i][1];
            f := q1*q2;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum44 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  
            
        
  // Pairing two distinct quartics whose associated involutions have 
  // irrational fixed points:

  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        M2 := PGLreduce(involutionirrat*M);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M
        M2 := PGLreduce(M2*involutionirrat);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M*involutionirrat
        M2 := PGLreduce(involutionirrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M*involutionirrat
        // We have a good one. Now use it to make pairs of quartics.
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);

        newinvolution := PGLreduce(M^-1*involutionirrat*M);
        if newinvolution eq involutionirrat then
          autgroup := [I,involutionirrat];
        else
          autgroup := [I];
        end if;
        
        for j in [2..#quarticsirrat] do
          q2 := Numerator(Evaluate(quarticsirrat[j][1],lft));
          q2 := q2/Coefficient(q2,4);
          for i in [1..j-1] do
            q1 := quarticsirrat[i][1];
            f := q1*q2;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum44 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  

  // Pairing two quartics, one of whose associated involutions has rational
  // fixed points and the other of whose does not.

  autgroup := [I];

  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        M2 := PGLreduce(involutionirrat*M);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M
        M2 := PGLreduce(M2*involutionrat);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M*involutionrat
        M2 := PGLreduce(involutionirrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M*involutionrat
        // We have a good one. Now use it to make pairs of quartics.
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);

        for j in [1..#quarticsirrat] do
          q2 := Numerator(Evaluate(quarticsirrat[j][1],lft));
          q2 := q2/Coefficient(q2,4);
          for i in [1..#quarticsrat] do
            q1 := quarticsrat[i][1];
            f := q1*q2;

            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;
  
            for C in Cs do
              checksum44 +:= 1/C[2];
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  

  // Pairing a quartic whose associated involution has rational fixed points
  // with itself.
  
  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        if M eq I or M eq involutionrat then continue b; end if;
        M2 := PGLreduce(involutionrat*M);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M
        M2 := PGLreduce(M2*involutionrat);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M*involutionrat
        M2 := PGLreduce(involutionrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M*involutionrat
        M2 := PGLreduce(M2^-1);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M^-1
        M2 := PGLreduce(involutionrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M^-1
        M2 := PGLreduce(M2*involutionrat);
        if M2 lt M then continue b; end if; // Compare M to M^-1*involutionrat
        M2 := PGLreduce(involutionrat*M2);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M^-1*involutionrat

        // We have a good one. 
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);

        // We will have q2(x) = q1(M(x)). Here we must avoid M = 1 and M = inv1.
        // Automorpshisms?
        // Aut(q1) intersect M^-1*Aut(q1)*M  gives the ones fixing each term.
        // For these curves that means inv1 if inv1 = M^-1 inv1 M.
        // Are there any that swap factors? 
        // The elements of PGL2 that take q1 to q2 are: 
        //  A = M                q1(A(x)) = q1(M(x)) = q2(x)
        //  A = inv1*M           q1(inv1(M(x)) = q1(M(x)) = q2(x)
        //  A = M*inv2 = inv1*M  q1((M*inv2)(x)) = q1(M*M^-1*inv1*M(x)) = q1(inv1(M(x))) = q1(M(x)) = q2(x)
        //  A = inv1*M*inv2 = M
        // So really only two choices, M and inv1*M.
        // And to give an automorphism of q1*q2 we would need q2(A(x)) = q1(x) so q1((M*A)(x)) = q1(x)
        // M*A = 1   or   M*A = inv1
        // For our two possibilities, this means:
        // A = M      and (M^2 = 1 or M^2 = inv1)
        // A = inv1*M and (M*inv1*M = 1   or   M*inv1*M = inv1) which is equiv to (A^2 = 1 or A^2 = inv)

        newinvolution := PGLreduce(M^-1*involutionrat*M);
        if newinvolution eq involutionrat then
          autgroup := [I,involutionrat];
        else
          autgroup := [I];
        end if;

        for A in [M, involutionrat*M] do
          A2 := PGLreduce(A^2);
          if A2 eq I or A2 eq involutionrat then autgroup cat:= [A]; end if;
        end for;

        for i in [1..#quarticsrat] do
          q1 := quarticsrat[i][1];
          q2 := Numerator(Evaluate(q1,lft));
          q2 := q2/Coefficient(q2,4);
          f := q1*q2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            checksum44 +:= 1/C[2];
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;



  // Pairing a quartic whose associated involution has irrational fixed points
  // with itself.
  
  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        if M eq I or M eq involutionirrat then continue b; end if;
        M2 := PGLreduce(involutionirrat*M);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M
        M2 := PGLreduce(M2*involutionirrat);
        if M2 lt M then continue b; end if; // Compare M to involutionrat*M*involutionirrat
        M2 := PGLreduce(involutionirrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M*involutionirrat
        M2 := PGLreduce(M2^-1);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M^-1
        M2 := PGLreduce(involutionirrat*M2);
        if M2 lt M then continue b; end if; // Compare M to M^-1
        M2 := PGLreduce(M2*involutionirrat);
        if M2 lt M then continue b; end if; // Compare M to M^-1*involutionirrat
        M2 := PGLreduce(involutionirrat*M2);
        if M2 lt M then continue b; end if; // Compare M to involutionirrat*M^-1*involutionirrat

        // We have a good one. 
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);

        // We will have q2(x) = q1(M(x)). Here we must avoid M = 1 and M = inv2.
        // Automorpshisms?
        // Aut(q1) intersect M^-1*Aut(q1)*M  gives the ones fixing each term.
        // For these curves that means inv1 if inv2 = M^-1 inv2 M.
        // Are there any that swap factors? 
        // The elements of PGL2 that take q1 to q2 are: 
        //  A = M                q1(A(x)) = q1(M(x)) = q2(x)
        //  A = inv2*M           q1(inv2(M(x)) = q1(M(x)) = q2(x)
        //  A = M*inv2 = inv1*M  q1((M*inv2)(x)) = q1(M*M^-1*inv1*M(x)) = q1(inv1(M(x))) = q1(M(x)) = q2(x)
        //  A = inv1*M*inv2 = M
        // So really only two choices, M and inv1*M.
        // And to give an automorphism of q1*q2 we would need q2(A(x)) = q1(x) so q1((M*A)(x)) = q1(x)
        // M*A = 1   or   M*A = inv1
        // For our two possibilities, this means:
        // A = M      and (M^2 = 1 or M^2 = inv1)
        // A = inv1*M and (M*inv1*M = 1   or   M*inv1*M = inv1) which is equiv to (A^2 = 1 or A^2 = inv)

        newinvolution := PGLreduce(M^-1*involutionirrat*M);
        if newinvolution eq involutionirrat then
          autgroup := [I,involutionirrat];
        else
          autgroup := [I];
        end if;

        for A in [M, involutionirrat*M] do
          A2 := PGLreduce(A^2);
          if A2 eq I or A2 eq involutionirrat then autgroup cat:= [A]; end if;
        end for;

        for i in [1..#quarticsirrat] do
          q1 := quarticsirrat[i][1];
          q2 := Numerator(Evaluate(q1,lft));
          q2 := q2/Coefficient(q2,4);
          f := q1*q2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            checksum44 +:= 1/C[2];
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;


  // Pairing the special quartic with a quartic whose associated involution
  // has rational fixed points.
  
  // First, get the automorphism of order 4.

  specialauts := special[1][3];  
  i := 0;
  repeat 
    i+:=1; 
    aut4 := specialauts[i];
  until PGLreduce(aut4*aut4) ne I;

  specialinvolution := PGLreduce(aut4^2);

  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        Mlist := [PGLreduce(involutionrat^i * M * aut4^j) : i in [0..1], j in [0..3]];
        if M ne Min(Mlist) then continue b; end if;
        // We have a good one. 
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
        newinvolution := PGLreduce(M^-1*involutionrat*M);
        if newinvolution eq specialinvolution then
          autgroup := [I,specialinvolution];
        else
          autgroup := [I];
        end if;

        
        q1 := special[1][1];

        for i in [1..#quarticsrat] do
          q2 := Numerator(Evaluate(quarticsrat[i][1],lft));
          q2 := q2/Coefficient(q2,4);
          f := q1*q2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            checksum44 +:= 1/C[2];
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;
  
        

  // Pairing the special quartic with a quartic whose associated involution
  // has irrational fixed points.
  
  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        Mlist := [PGLreduce(involutionirrat^i * M * aut4^j) : i in [0..1], j in [0..3]];
        if M ne Min(Mlist) then continue b; end if;
        // We have a good one. 
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
        newinvolution := PGLreduce(M^-1*involutionirrat*M);
        if newinvolution eq specialinvolution then
          autgroup := [I,specialinvolution];
        else
          autgroup := [I];
        end if;

        
        q1 := special[1][1];

        for i in [1..#quarticsirrat] do
          q2 := Numerator(Evaluate(quarticsirrat[i][1],lft));
          q2 := q2/Coefficient(q2,4);
          f := q1*q2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            checksum44 +:= 1/C[2];
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
    end for;
  end for;
  
        

  // And finally, pair the special one with itself.

  auts := [PGLreduce(aut4^i) : i in [0..3]];
  q1 := special[1][1];

  for cd in [ [0,1] ] cat [ [1,a] : a in K] do
    c,d := Explode(cd);
    for a,b in K do
      if a*d ne b*c then
        M := Matrix(2,[a,b,c,d]);
        Mlist := [PGLreduce(aut4^i * M^k * aut4^j) : i in [0..3], j in [0..3], k in [-1,1]];
        if M ne Min(Mlist) then continue b; end if;
        if M in auts then continue b; end if;
        
        // We have a good one. 
        lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
  

        newauts := [PGLreduce(M^-1*A*M) : A in auts];
    
        // First, the automorphisms that fix both factors individually
        autgroup := [A : A in auts | A in newauts];
    
        // Things that move first factor to second: A*M for A in auts.
        // Moves second to first if M*A*M in auts.
        autgroup cat:= [PGLreduce(A*M) : A in auts | PGLreduce(M*A*M) in auts];

        q2 := Numerator(Evaluate(q1, lft));
        q2 := q2/Coefficient(q2,4);
        f := q1*q2;

        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;
  
        for C in Cs do
          checksum44 +:= 1/C[2];
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end if;
    end for;
  end for;
  
  assert checksum44 eq q*(q^4 - q^2 - 4)/32;


  // Galois type (4,3,1):
  // We skip this Galois type if the flag skip431 is set.
  
  if not skip431 then
  
    checksum431 := 0;
    
    // Loop through automorphism groups.
    // Loop through degree-3 places up to the automorphism group.
    // Loop through quartics with the given automorphism group.
    // Loop through rational points.
    
    autgroup := [I];
    
    // Order 2, rational fixed points.
    // Note that every cubic that is not irreducible has a rational root.
    M := involutionrat;
    lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
    
    for a,b in K do
      partialcubic := x^3 + a*x^2 + b*x;
      badcs := {-Evaluate(partialcubic,z) : z in K};
      for c in K do 
        if not c in badcs then
          cubic := partialcubic + c;
          cubic2 := Numerator(Evaluate(cubic,lft));
          cubic2 := cubic2/Coefficient(cubic2,3);
          if cubic2 lt cubic then continue c; end if;
          
          checksum431 +:= #quarticsrat*#linears;
          
          for quartic in quarticsrat do
            g := quartic[1]*cubic;
            for linear in linears do
              f := linear*g;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;
    
              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;
          end for;
        end if;
      end for;
    end for;
    
    M := involutionirrat;
    lft := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
    
    for a,b in K do
      partialcubic := x^3 + a*x^2 + b*x;
      badcs := {-Evaluate(partialcubic,z) : z in K};
      for c in K do 
        if not c in badcs then
          cubic := partialcubic + c;
          cubic2 := Numerator(Evaluate(cubic,lft));
          cubic2 := cubic2/Coefficient(cubic2,3);
          if cubic2 lt cubic then continue c; end if;
          
          checksum431 +:= #quarticsirrat*#linears;
          
          for quartic in quarticsirrat do
            g := quartic[1]*cubic;
            for linear in linears do
              f := linear*g;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;
    
              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;
          end for;
        end if;
      end for;
    end for;

    M := aut4;
    lft1 := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
    M := PGLreduce(aut4^2);
    lft2 := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
    M := PGLreduce(aut4^3);
    lft3 := (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]);
            
    for a,b in K do
      partialcubic := x^3 + a*x^2 + b*x;
      badcs := {-Evaluate(partialcubic,z) : z in K};
      for c in K do 
        if not c in badcs then
          cubic := partialcubic + c;
          for lft in [lft1,lft2,lft3] do
            cubic2 := Numerator(Evaluate(cubic,lft));
            cubic2 := cubic2/Coefficient(cubic2,3);
            if cubic2 lt cubic then continue c; end if;
          end for;
          
          checksum431 +:= #special*#linears;
          
          for quartic in special do
            g := quartic[1]*cubic;
            for linear in linears do
              f := linear*g;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;
    
              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;
          end for;
        end if;
      end for;
    end for;

    assert checksum431 eq q^2 * (q+1)^2 * (q-1) / 12;

  end if;
  
  // Galois type (4,2,2):
  checksum422 := 0;

  // For each of the three automorphism groups occuring in our list of quartics,
  // make a list of the quadratics, grouped by orbit under these automorphisms.
  // List the order-4 orbits before the order-2, and the order-2 before the
  // order-1 orbits.
  //
  // Take two quadratics from the list. Demand that the smaller be first in its
  // orbit, and if the orbit has size 4, then the second quadratic should not
  // be the next one on the list after the first.
   
  // For the automorphism groups of order 2, we can identify the automorphism
  // group of the whole degree-8 divisor as follows: It has order 2 if the two
  // quadratics are in the same orbit, or if they are both unique in their
  // orbits, and order 1 otherwise.
  
  // For the automorphism group of order 4, the automorphism group of the whole
  // degree-8 divisor is as follows: 
  // If the two quadratics are in the same orbit and it has size 4 and
  // they are not adjacent (mod 4): order 2.
  // If the two quadratics are in the same orbit and it has size 2: order 4.
  // If the two quadratics are each in orbits of size 1 or 2: order 2.
  // Otherwise, order 1.
  
  quadratics := [x^2 + a*x + b : a,b in K | not IsSquare(a^2-4*b)];
  
  lftrat :=  (involutionrat[1,1]*x + involutionrat[1,2])
             /(involutionrat[2,1]*x + involutionrat[2,2]);
  lftirrat :=  (involutionirrat[1,1]*x + involutionirrat[1,2])
              /(involutionirrat[2,1]*x + involutionirrat[2,2]);
  lftspecial := (aut4[1,1]*x + aut4[1,2])
               /(aut4[2,1]*x + aut4[2,2]);
  
            
  orbitsrat1 := [];
  orbitsrat2 := [];
  taken := {};
  for quad in quadratics do
    if not quad in taken then
      quad2 := Numerator(Evaluate(quad,lftrat));
      quad2 := quad2/Coefficient(quad2,2);
      if quad2 eq quad then
        orbitsrat1 cat:= [<1,quad,quad>];
      else
        orbitsrat2 cat:= [<2,quad,quad>, <2,quad,quad2>];
      end if;
      taken join:= {quad,quad2};
    end if;
  end for;

  orbitsrat := orbitsrat2 cat orbitsrat1;
  
  orbitsirrat1 := [];
  orbitsirrat2 := [];
  taken := {};
  for quad in quadratics do
    if not quad in taken then
      quad2 := Numerator(Evaluate(quad,lftirrat));
      quad2 := quad2/Coefficient(quad2,2);
      if quad2 eq quad then
        orbitsirrat1 cat:= [<1,quad,quad>];
      else
        orbitsirrat2 cat:= [<2,quad,quad>, <2,quad,quad2>];
      end if;
      taken join:= {quad,quad2};
    end if;
  end for;

  orbitsirrat := orbitsirrat2 cat orbitsirrat1;
  
  orbitsspecial1 := [];
  orbitsspecial2 := [];
  orbitsspecial4 := [];
  taken := {};
  for quad in quadratics do
    if not quad in taken then
      quad2 := Numerator(Evaluate(quad,lftspecial));
      quad2 := quad2/Coefficient(quad2,2);
      quad3 := Numerator(Evaluate(quad2,lftspecial));
      quad3 := quad3/Coefficient(quad3,2);
      quad4 := Numerator(Evaluate(quad3,lftspecial));
      quad4 := quad4/Coefficient(quad4,2);
      

      if quad2 eq quad then
        orbitsspecial1 cat:= [<1,quad,quad>];
      elif quad3 eq quad then
        orbitsspecial2 cat:= [<2,quad,quad>, <2,quad,quad2>];
      else
        orbitsspecial4 cat:= [<4,quad,quad>, <4,quad,quad2>, <4,quad,quad3>, <4,quad,quad4>];
      end if;
      taken join:= {quad,quad2,quad3,quad4};
    end if;
  end for;

  orbitsspecial := orbitsspecial4 cat orbitsspecial2 cat orbitsspecial1;
  
  
  for i in [1..#orbitsrat-1] do
    if orbitsrat[i][2] eq orbitsrat[i][3] then
      // We've got one that's first in its orbit.
      quad1 := orbitsrat[i][3];
      unique1 := (orbitsrat[i][1] eq 1);

      for j in [i+1..#orbitsrat] do
        quad2 := orbitsrat[j][3];
        if unique1 or (orbitsrat[j][2] eq quad1) then
          autgroup := [I,involutionrat];
        else
          autgroup := [I];
        end if;
          
        g := quad1*quad2;

        checksum422 +:= #quarticsrat/#autgroup;
          
        for quartic in quarticsrat do        
          f := quartic[1]*g;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end if;
  end for;
  
  for i in [1..#orbitsirrat-1] do
    if orbitsirrat[i][2] eq orbitsirrat[i][3] then
      // We've got one that's first in its orbit.
      quad1 := orbitsirrat[i][3];
      unique1 := (orbitsirrat[i][1] eq 1);

      for j in [i+1..#orbitsirrat] do
        quad2 := orbitsirrat[j][3];
        if unique1 or (orbitsirrat[j][2] eq quad1) then
          autgroup := [I,involutionirrat];
        else
          autgroup := [I];
        end if;
          
        g := quad1*quad2;

        checksum422 +:= #quarticsirrat/#autgroup;
          
        for quartic in quarticsirrat do        
          f := quartic[1]*g;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end if;
  end for;
  
  for i in [1..#orbitsspecial-1] do
    if orbitsspecial[i][2] eq orbitsspecial[i][3] then
      // We've got one that's first in its orbit.
      quad1 := orbitsspecial[i][3];
      if orbitsspecial[i][1] eq 4 then
        jstart := i+2;
      else 
        jstart := i+1;
      end if;
      
      for j in [jstart..#orbitsspecial] do
        quad2 := orbitsspecial[j][3];

        case orbitsspecial[i][1]:
          when 4:
            if j eq i + 2 then 
              // Same size-4 orbit, non adjacent
              autgroup := [I, specialinvolution];
            else
              autgroup := [I];
            end if;
          when 2:
            if j eq i + 1 then 
              // Same size-2 orbit
              autgroup := specialauts;
            else 
              // Both are in size-2 or size-1 orbits
              autgroup := [I,specialinvolution];
            end if;
          when 1: 
              // Both are in size-1 orbits
            autgroup := [I,specialinvolution];
        end case;
 
        f := quad1*quad2*special[1][1];
        checksum422 +:= 1/#autgroup;

        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;
  
        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
  end for;
  
  assert checksum422 eq q^2 * (q+1) * (q-1) * (q-2) / 32;

  
  
   // Galois type (4,2,1,1):
  checksum4211 := 0;
  
  // Similar in spirit to the (4,2,2) case:
  
  // For each of the three automorphism groups occuring in our list of quartics,
  // make a list of the irreducible quadratics and the split quadratic, grouped
  // by orbit under these automorphisms. List the order-4 orbits before the
  // order-2, and the order-2 before the order-1 orbits.
  //
  // Take one quadratic from each list, say qirred and qsplit. Demand that the
  // one of these in the larger orbit (with ties going to the irreducible one)
  // be first in its orbit. That will be enough to normalize the curve.
  // 
  // For the automorphism groups of order 2, we can identify the automorphism
  // group of the whole degree-8 divisor as follows: It has order 2 if the two
  // quadratics are both in orbits of size 1, and order 1 otherwise.
  //
  // For the automorphism group of order 4, the automorphism group of the 
  // degree-8 divisor has order 2 if each quadratic is in an orbot of size less
  // than 4, and has order 1 otherwise.
  
  // We already have the irreducible quadratics in "quadratics". We will also
  // want the split quadratics.
  
  twolinears := [x-a : a in K] cat [(x-a)*(x-b) : a,b in K | a lt b];

  automorphismgenerators := [lftrat, lftirrat, lftspecial];
  automorphismgroups := [[I,involutionrat], [I,involutionirrat], specialauts];
  quartictypes := [[a[1] : a in quarticsrat], [a[1]: a in quarticsirrat], [a[1] : a in special]];

  for i in [1..3] do
    lft := automorphismgenerators[i];
    quarticauts := automorphismgroups[i];
    den := Denominator(lft);
    drawfrom := quartictypes[i];
    
    twolinears1 := [];
    twolinears2 := [];
    twolinears4 := [];
    taken := {};
    for lins in twolinears do
      if not lins in taken then
        lins2 := Numerator(Evaluate(lins,lft)*den^2);
        lins2 := lins2/Coefficient(lins2,Degree(lins2));
        lins3 := Numerator(Evaluate(lins2,lft)*den^2);
        lins3 := lins3/Coefficient(lins3,Degree(lins3));
        lins4 := Numerator(Evaluate(lins3,lft)*den^2);
        lins4 := lins4/Coefficient(lins4,Degree(lins4));
      
        if lins2 eq lins then
          twolinears1 cat:= [lins];
        elif lins3 eq lins then
          twolinears2 cat:= [lins,lins2];
        else
          twolinears4 cat:= [lins,lins2,lins3,lins4];
        end if;
        taken join:= {lins,lins2,lins3,lins4};
      end if;
    end for;

    onequadratic1 := [];
    onequadratic2 := [];
    onequadratic4 := [];
    taken := {};
    for quad in quadratics do
      if not quad in taken then
        quad2 := Numerator(Evaluate(quad,lft)*den^2);
        quad2 := quad2/Coefficient(quad2,2);
        quad3 := Numerator(Evaluate(quad2,lft)*den^2);
        quad3 := quad3/Coefficient(quad3,2);
        quad4 := Numerator(Evaluate(quad3,lft)*den^2);
        quad4 := quad4/Coefficient(quad4,2);
      
        if quad2 eq quad then
          onequadratic1 cat:= [quad];
        elif quad3 eq quad then
          onequadratic2 cat:= [quad,quad2];
        else
          onequadratic4 cat:= [quad,quad2,quad3,quad4];
        end if;
        taken join:= {quad,quad2,quad3,quad4};
      end if;
    end for;
    
    
    autgroup := [I];
    for j in [1..#onequadratic4 by 4] do
      g1 := onequadratic4[j];
      for g2 in twolinears4 cat twolinears2 cat twolinears1 do
        checksum4211 +:= #drawfrom/#autgroup;
        for quartic in drawfrom do
          f := quartic*g1*g2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
    
    for j in [1..#twolinears4 by 4] do
      g1 := twolinears4[j];
      for g2 in onequadratic2 cat onequadratic1 do
        checksum4211 +:= #drawfrom/#autgroup;
        for quartic in drawfrom do
          f := quartic*g1*g2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
    
    case #quarticauts:
      when 2: autgroup := [I];
      when 4: autgroup := [I, PGLreduce(aut4^2)];
    end case;
    
    for j in [1..#onequadratic2 by 2] do
      g1 := onequadratic2[j];
      for g2 in twolinears2 cat twolinears1 do
        checksum4211 +:= #drawfrom/#autgroup;
        for quartic in drawfrom do
          f := quartic*g1*g2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
    
    for j in [1..#twolinears2 by 2] do
      g1 := twolinears2[j];
      for g2 in onequadratic1 do
        checksum4211 +:= #drawfrom/#autgroup;
        for quartic in drawfrom do
          f := quartic*g1*g2;

          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;
  
          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end for;
    end for;
    
    autgroup := quarticauts;
    for g1 in onequadratic1, g2 in twolinears1 do
      checksum4211 +:= #drawfrom/#autgroup;
      for quartic in drawfrom do
        f := quartic*g1*g2;

        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;
  
        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end for;
  end for;


  assert checksum4211 eq q^3 * (q+1) * (q-1) / 16;


  // Galois type (4,1,1,1,1):
  checksum41111 := 0;
  
  // Loop over automorphism groups A of quartics.
  // Group the elements of P^1(K) by orbit under action of A.
  // List the elements, with the larger orbits first.
  // Loop through 4-element subsets of this list, demanding that smallest
  // element be first in its orbit.
  // Loop through quartics with automorphism group A.
  
  for i in [1..3] do
    lft := automorphismgenerators[i];
    quarticauts := automorphismgroups[i];
    den := Denominator(lft);
    drawfrom := quartictypes[i];

    linears := [1] cat [x-a : a in K];
    Ponelist := [];
    Ponelist4 := [];
    Ponelist2 := [];
    Ponelist1 := [];
    taken := {};
    
    count := 1;
    for lin in linears do
      if not lin in taken then
        lin2 := lin;
        orbit := [];
        repeat
          orbit cat:= [lin2];
          lin2 := Numerator(Evaluate(lin2,lft)*den);
          lin2 := lin2 / Coefficient(lin2,Degree(lin2));
        until lin2 eq lin;
        taken join:= {a : a in orbit};
        case #orbit:
          when 4: 
            Ponelist cat:= [<[count,count+1,count+2,count+3],  orbit[1],orbit[2],orbit[3]>,
                             <[count+1,count+2,count+3,count], orbit[2],orbit[3],orbit[4]>,
                             <[count+2,count+3,count,count+1], orbit[3],orbit[4],orbit[1]>,
                             <[count+3,count,count+1,count+2], orbit[4],orbit[1],orbit[2]>];
            count +:= 4;                             
          when 2: 
            Ponelist cat:= [<[count,count+1,count,count+1],  orbit[1],orbit[2],orbit[1]>,
                             <[count+1,count,count+1,count], orbit[2],orbit[1],orbit[2]>];
            count +:= 2;
          when 1: 
            Ponelist cat:= [<[count,count,count,count],  orbit[1],orbit[1],orbit[1]>];
            count +:= 1;
        end case;  
      end if;
    end for;
    
    for j1 in [1..#Ponelist-3] do
      if Ponelist[j1][1][1] eq Min(Ponelist[j1][1]) then
        g1 := Ponelist[j1][2];
        for j2 in [j1+1..#Ponelist-2] do
          g2 := g1*Ponelist[j2][2];
          for j3 in [j2+1..#Ponelist-1] do
            g3 := g2*Ponelist[j3][2];
            for j4 in [j3+1..#Ponelist] do
              g := g3*Ponelist[j4][2];
              
              choices := [Sort([Ponelist[j][1][k] : j in {j1,j2,j3,j4}]) : k in [1..4]];
              if choices[1] eq Sort(choices)[1] then

                if #quarticauts eq 4 then
                  if {Ponelist[k][2] : k in [j1,j2,j3,j4]} eq {Ponelist[k][3] : k in [j1,j2,j3,j4]} then
                    autgroup := quarticauts;
                  elif {Ponelist[k][2] : k in [j1,j2,j3,j4]} eq {Ponelist[k][4] : k in [j1,j2,j3,j4]} then
                    autgroup := [I, PGLreduce(aut4^2)];
                  else
                    autgroup := [I];
                  end if;
                else
                  if {Ponelist[k][2] : k in [j1,j2,j3,j4]} eq {Ponelist[k][3] : k in [j1,j2,j3,j4]} then
                    autgroup := quarticauts;
                  else
                    autgroup := [I];
                  end if;
                end if;

                checksum41111+:= #drawfrom/#autgroup;
  
                for quartic in drawfrom do
                  f := quartic*g;
  
                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;
  
                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end for;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  assert checksum41111 eq q^2 * (q+1) * (q-1) * (q-2) / 96;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;

//------------------------------------------------------------------------------

function genusthree5x(K : passback := true, curves := true, output := false, outputfile := "", skip521 := false)
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (5,...), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (5,...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // If skip521 = true, we skip the Galois type (5,2,1). This is helpful
  // when computing all genus-3 hyperelliptic curves, because genusthree71 runs
  // faster if we allow it to include this Galois type in its computation.
  // Since in this function we process all three Galois types at once, in order
  // do avoid type (5,2,1) we add a check making sure that the discriminant
  // of the cubic we are tacking on is a square (which means it has an even
  // number of even-degree factors).

  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:

  // Galois type (5,3):          q * (q^2+1) * (q+1) * (q-1) / 15
  // Galois type (5,2,1):        q * (q^2+1) * (q+1) * (q-1) / 10
  // Galois type (5,1,1,1):      q * (q^2+1) * (q+1) * (q-1) / 30

  // We check this at the end, but combined --- we do not calculate these types
  // separately.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well. In this case, all automorphism groups
  // will be trivial.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  zeta := PrimitiveElement(K);
  ns := nonsquare(K);
  irred3 := irreducible3(K);

  I := Matrix(2,[K|1,0,0,1]);
  autgroup := [I];

  linears := [1] cat [x-a : a in K];
  cubicstarts := [ [0,1] ] cat [ [1,a] : a in K];
  
  checksum := 0;

  // Our routine to compute PGL2 orbit representatives of irreducible quintics
  // is copy-and-pasted from Hyperelliptic2.magma. 

  // First deal with places with quintics with nontrivial automorphisms.
  // These are exactlty the ones with Frobenius functions of degree 1.
  // The paper tells us what they are.

  case q mod 5:
    when 0: 
      // Find an element of K of nonzero absolute trace.
      t := K!1;
      if Trace(t,GF(5)) eq 0 then
        repeat t*:=zeta;
        until Trace(t,GF(5)) ne 0;
      end if;
      A := Matrix(2,[K!1,1,0,1]);
      shortauts := [A^i : i in [1..4]]; // Everything but the identity.
      T := [x^5 - x - t];

    when 1: 
      rootof1 := zeta^((q-1) div 5);
      A := Matrix(2,[rootof1,0,0,1]);
      shortauts := [A^i : i in [1..4]];
      T := [x^5 - zeta, x^5 - zeta^2];
      
    when 4:
      KK := ext<K | 10>;
      zeta2 := PrimitiveElement(KK);
      // Want element of order 5*(q+1).
      // zeta2 has order q^10 - 1 
      xi := zeta2^((q^10-1) div (5*(q+1)));
      // Want an element ss of the quadratic extension of K in KK
      ss := xi^5;

      // Automorphisms:
      zeta := xi^(q+1); // Fifth root of 1
      r := (ss^(q) - zeta*ss)/(zeta-1);
      a := - ss - ss^(q);
      b := ss^(q+1);
      A := Matrix(2,[K|r-a,-b,1,r]);
      shortauts := [PGLreduce(A^i) : i in [1..4]];
      
      
      T := [MinimalPolynomial( (ss*xi   + ss^(q))/(xi   + 1), K),
            MinimalPolynomial( (ss*xi^2 + ss^(q))/(xi^2 + 1), K)];
    else
      T := [];
      shortauts := [];
  end case;

  if #shortauts eq 4 then
  
    rats := [ (M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortauts];
    dens := [ (M[2,1]*x + M[2,2])^3 : M in shortauts];
    
    for start in cubicstarts do
      c3,c2 := Explode(start);
      for c1 in K do
        g := c3*x^3 + c2*x^2 + c1*x;
        // Want to run through the c0 for which g + c0 has no 
        // repeated roots. If gprime is nonzero, the c0 to avoid
        // are the values -g(r) for r a root of gprime.
        // If gprime is 0, which may happen in characteristic 3,
        // then all values of c0 are bad.
        gprime := 3*c3*x^2 + 2*c2*x + c1;
        if gprime ne 0 then
          roots := [r[1] : r in Roots(gprime)];
          baduns := {-Evaluate(g,r) : r in roots};
        else
          baduns := {a : a in K};
        end if;
        for c0 in K do
          if not c0 in baduns then
            h := g + c0;
            // h represents a separable homogeneous cubic.
            // Separable because every nonseparable cubic has a rational
            // double root, and we have chose d so that h has no roots in
            // common with its derivative.
            
            // If the flag skip521 is set, also check that h has square
            // discriminant.
            
            if not skip521 or IsSquare(Discriminant(h)) then
              for i in [1..4] do
                h2 := Numerator(Evaluate(h,rats[i])*dens[i]);
                h2 := h2/Coefficient(h2,Degree(h2));
                if h2 lt h then continue c0; end if;
              end for;
              
              for quintic in T do
                f := h*quintic;
                checksum +:= 1;
                
                if curves then
                  Cs := curves_from_divisor(f,autgroup);
                else
                  Cs := [<f,#autgroup,autgroup>];
                end if;
    
                for C in Cs do
                  if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                  if passback then Clist cat:= [C]; end if;
                end for;
              end for;
            end if;
          end if;
        end for;
      end for;
    end for;
    
  end if;
  
  // Now move on to the ones with trivial automorphism groups.
  
  // We need reps for degree-3 divisors over K up to PGL(2,K).
  // 3*oo
  // 2*oo + 0
  // oo + 0 + 1
  // oo + irred2
  // irred3

  // D = 3*oo. The paper tells us exactly what to do in this case.
  // There are only two associated functions:
  // (x^2 + y^2)/(xy) and (x^2 + ns*y^2)/(xy), where ns is a nonsquare in K.

  for F in [(x^2+1)/x, (x^2+ns)/x] do
    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];

        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;

      end if;
    end for;
  end for;


  // D = 2*oo + 0. The paper tells us exactly what to do in this case.
  // The functions to consider are
  // (x^2 + sx)/(x + 1)  where s!=1
  
  for a in K do 
    if a eq 1 then continue a; end if;
    F := (x^2+a*x)/(x+1);
    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;


  // oo + 0 + 1
  // oo + irred2
  // irred3

  // D = oo + 0 + 1.
  // r := 2;
  // p = y*z*(y-z)
  // want (y*h - c*p)/(z*h) where h has degree 2 and gcd with p is z
  // and where c is nonzero and cp != yh mod z^2
  // c*y^2*z != y*h mod z^2
  // h = z*(y + b*z)
  // c*y^2*z != y^2*z  so c!=1
  // (y*z*(y + b*z) - c*y*z*(y-z)) / (z^2*y + b*z^3)
  // (y*(y + b*z) - c*y*(y-z)) / (z*y + b*z^2)
  // (y^2 + b*y*z - c*y^2 + c*y*z) / (z*y + b*z^2)
  // ((1-c)*y^2 + (b+c)*y) / (y + b)   b arbitrary, c nonzero, non-1

  // Elements of PGL2 that fix D  
  Dmatrixauts := [ Matrix(2,[K |  1,  0, 0,  1]),
                   Matrix(2,[K |  0, -1, 1, -1]),
                   Matrix(2,[K |  1,  0, 1, -1]),
                   Matrix(2,[K |  0,  1, 1,  0]),
                   Matrix(2,[K |  1, -1, 1,  0]),
                   Matrix(2,[K | -1,  1, 0,  1]) ];
             
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             
             

  for b,c in K do
    if c^2 eq c then continue c; end if;
    F := ((1-c)*x^2 + (b+c)*x)/(x + b);  

    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  
  
  // D = oo + irred2.
  // r := 2;
  // p = z*(y^2 - ns*z^2)
  // want (y*h - c*p)/(z*h) where h has degree 2 and gcd with p is z
  // and where c is nonzero and cp != yh mod z^2
  
  // First, h = z^2.
  // c*z*(y^2 - ns*z^2) != 0 mod z^2
  // c*y^2 != 0 mod z
  
  // Second, h = z*(y + b*z).
  // c*z*(y^2 - ns*z^2) != y*z*(y + b*z) mod z^2
  // c*z*y^2 - c*ns*z^3 != y^2*z + b*y*z^2 mod z^2
  // c*z*y^2 != y^2*z  mod z^2
  // c != 1, b arbitrary

  // y*(y + b) - c*(y^2 - ns)    y^2 + b*y - c*y^2 + ns*c
  // ------------------------- = ------------------------
  // (y + b)                     y + b
  
  
  // Elements of PGL2 that fix D  
  // y --> -y
  Dmatrixauts := [ Matrix(2,[K |  1, 0, 0, 1]),
                   Matrix(2,[K | -1, 0, 0, 1]) ];
             
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             
             


  // First, h = z^2:

  for c in K do
    if c eq 0 then continue c; end if;
    F := c*x^2 + x - c*ns;

    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
  
  // Next, h =  h = z*(y + b*z)
    
  for b,c in K do
    if c^2 eq c then continue c; end if;
    F := ((1-c)*x^2 + b*x + ns*c)/(x + b);
    
    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue c; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;
 

  // D = irred3.
  // r := 2;
  // p = irred3
  // want (y*h - irred3)/(z*h) where h is monic, degree 2, coprime to z
  // h = y^2 + a*y + b 
  
  // Elements of PGL2 that fix irred3

  Dmatrixauts := [I,Matrix(2,[0,-1,1,-1]), Matrix(2,[1,-1,1,0])];
  Dmatrixautsinverse := [M^-1 : M in Dmatrixauts];             

  Dfunctionauts := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixauts];             
  Dfunctionautsinverse := [(m[1,1]*x + m[1,2])/(m[2,1]*x + m[2,2]) : m in Dmatrixautsinverse];             

  for a,b in K do
    F := (x^3 + a*x^2 + b*x - irred3)/(x^2 + a*x + b);
    
    for i in [2..#Dfunctionauts] do
      Fprime := Evaluate(Dfunctionauts[i],Evaluate(F,Dfunctionautsinverse[i]));
      if Fprime lt F then continue b; end if;
    end for;

    F2 := Evaluate(F,F);
    F4 := Evaluate(F2,F2);
    F5 := Evaluate(F4,F);
    g := Numerator(x - F5);
    shortlist := [];
    facg := [ff[1] : ff in Factorization(g) | Degree(ff[1]) eq 5];    
    for ff in facg do
      if IsFrobeniusFunction(F,ff) then
        shortlist cat:= [<cross(ff),ff>];
      end if;
    end for;
    Sort(~shortlist);
    for i in [1..#shortlist] do
      if i eq 1 or shortlist[i][1] ne shortlist[i-1][1] then
        quintic := shortlist[i][2];
        for start in cubicstarts do
          c3,c2 := Explode(start);
          for c1 in K do
            g := c3*x^3 + c2*x^2 + c1*x;
            // Want to run through the c0 for which g + c0 has no 
            // repeated roots. If gprime is nonzero, the c0 to avoid
            // are the values -g(r) for r a root of gprime.
            // If gprime is 0, which may happen in characteristic 3,
            // then all values of c0 are bad.
            gprime := 3*c3*x^2 + 2*c2*x + c1;
            if gprime ne 0 then
              roots := [r[1] : r in Roots(gprime)];
              baduns := {-Evaluate(g,r) : r in roots};
            else
              baduns := {a : a in K};
            end if;
            for c0 in K do
              if not c0 in baduns then
                h := g + c0;
                if not skip521 or IsSquare(Discriminant(h)) then
                  f := quintic*h;
                  checksum +:= 1; 

                  if curves then
                    Cs := curves_from_divisor(f,autgroup);
                  else
                    Cs := [<f,#autgroup,autgroup>];
                  end if;

                  for C in Cs do
                    if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                    if passback then Clist cat:= [C]; end if;
                  end for;
                end if;
              end if;
            end for;
          end for;
        end for;
      end if;
    end for;
  end for;

  if skip521 then
    assert checksum eq q * (q^2+1) * (q+1) * (q-1) / 10;
  else 
    assert checksum eq q * (q^2+1) * (q+1) * (q-1) / 5;
  end if;

  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;






//------------------------------------------------------------------------------

function genusthree6x(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (6,...), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (6,...),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:

  // Galois type (6,2):         q*(q-1)*(q^3 + q - 1)/12
  // Galois type (6,1,1):       q*(q+1)*(q^3 + q - 1)/12

  // We check this at the end, but combined --- we do not calculate these types
  // separately.
  
  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  ns := nonsquare(K);
  R<x>:=PolynomialRing(K);
  L<beta>:=ext<K | x^2 - ns>;
  M := ext<L | 3>;
  alpha := Roots(irreducible3(K),M)[1][1];
  I := Matrix(2,[K|1,0,0,1]);

  checksum := 0;
  
  quadratics := [x - a : a in K] cat [x^2 + a*x + b : a,b in K | a^2-4*b ne 0];
  
  // Get representatives for the PGL2 orbits of the irreducible sextics. We
  // copy-and-past the code from Hyperelliptic2.magma.
  
  // First: triples (oo, 0, beta + a).
  // The ones with a nonzero...

  // sextic automorphism group is trivial for these.
  autgroup := [I];
  
  for a in K do
    if a eq 0 or a gt -a then continue a; end if;
    
    // Process it:
    aa := beta+a;
    bb := 0;
    cc := 0;
    dd := 1;
    g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    
    for quad in quadratics do
      f := g*quad;
      checksum +:= 1; 
      
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end for;
    

  // ... and the ones with a = 0, in which case we get an involution.

  involution := Matrix(2,[K| -1,0,0,1]);
  
  aa := beta;
  bb := 0;
  cc := 0;
  dd := 1;
  g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
  
  for quad in quadratics do
    quad2 := (-1)^Degree(quad)*Evaluate(quad,-x);
    if quad2 lt quad then continue quad; end if;
    if quad2 eq quad then
      autgroup := [I,involution];
    else
      autgroup := [I];
    end if;
    
    f := g*quad;
    checksum +:= 1/#autgroup; 
    
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end for;
   
  // Second: triples (oo, beta, theta), where theta = b*beta + a with a distinct
  // up to sign and b nonzero and with (b,a) != (1,0).
  // The ones with a nonzero...
  // These have trivial automorphism group.
  
  autgroup := [I];  

  for a,b in K do
    if a gt -a or a eq 0 or b eq 0 then continue b; end if;
    aa := (b*beta+a)-beta;
    bb := beta;
    cc := 0;
    dd := 1;
    g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    for quad in quadratics do
      f := g*quad;
      checksum +:= 1; 
      
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end for;
  
  // ... and the ones with a = 0, in which case we get an involution.
  
  involution := Matrix(2,[K| -1,0,0,1]);
  
  for b in K do
    if b eq 0 or b eq 1 then continue b; end if;
    
    aa := (b*beta)-beta;
    bb := beta;
    cc := 0;
    dd := 1;
    g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);

    for quad in quadratics do
      quad2 := (-1)^Degree(quad)*Evaluate(quad,-x);
      if quad2 lt quad then continue quad; end if;
      if quad2 eq quad then
        autgroup := [I,involution];
      else
        autgroup := [I];
      end if;
    
      f := g*quad;
      checksum +:= 1/#autgroup; 
    
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end for;
  
  // Third: triples (beta, -beta, theta) for theta unique up to the action of
  // the subgroup of PGL(2,K) that fixes beta.
  
  orbitreps := betaorbitreps(K,beta);
  // This is a set of orbit representatives for the action on 
  // P^1(L)\{beta,beta^q} of the subgroup of PGL(2,K) that fixes beta.
  // Note that this has size O(q). 
  
  // Remove the rational orbit.
  orbitreps := [a : a in orbitreps | not a in K];
  
  for theta in orbitreps do
    // We have an automorphism.
    aut := PGLreduce(Matrix(2,[K|ns + Norm(theta,K), -ns*Trace(theta,K), 
                               Trace(theta,K), -ns -Norm(theta,K)]));
    rat := (aut[1,1]*x + aut[1,2])/(aut[2,1]*x + aut[2,2]);
    den := (aut[2,1]*x + aut[2,2])^2;
    
    aa := beta*(beta+theta);
    bb := beta*(theta-beta);
    cc := beta+theta;
    dd := beta-theta;
    
    g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
    
    for quad in quadratics do
      quad2 := Numerator(Evaluate(quad,rat)*den);
      quad2 := quad2/Coefficient(quad2,Degree(quad2));
      
      if quad2 lt quad then continue quad; end if;
      if quad2 eq quad then
        autgroup := [I,aut];
      else
        autgroup := [I];
      end if;
    
      f := g*quad;
      checksum +:= 1/#autgroup; 
    
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end for;
    
    
  // We will have beta, eta, theta. We want to distiguish between this ordered
  // triple and its rotations. 
  
  for eta in orbitreps do
    
    normeta := Norm(eta,K);
    traceeta := Trace(eta,K);
    etaq := traceeta-eta;
    
    aaa := (ns + normeta)/traceeta;
    bbb := aaa^2 - ns;
    assert eta eq aaa + bbb/(etaq - aaa);
    
    // The map x --> aaa + bbb/(x - aaa) takes beta^q to beta and eta^q to eta.
    
    // Compute as much of our crossratios as we can at this point.
    jj1 := (beta + eta) / (2 * beta);
    jj2 := (eta - beta) / (eta - etaq);
    jj3 := 1 / (eta - beta);
    

    // Now we want theta to run over all elements of L that are not in K
    // and not equal to beta or beta^q and not equal to eta or eta^q.
    
    betaq := beta^q;

    for theta in L do
      if theta in K then continue theta; end if;
      if theta eq beta or theta eq betaq then continue theta; end if;
      if theta eq eta  or theta eq etaq  then continue theta; end if;
      
      // Also check that [beta, eta, theta] is minimal under conjugation.
      thetaq := theta^q;
      thetaprime := aaa + bbb/(thetaq - aaa);
      if theta gt thetaprime then continue theta; end if;

      tracetheta := Trace(theta,K);
      normtheta := Norm(theta,K);
      
      j1 := jj1 *   (beta - theta) / ( eta - theta);
      j2 := jj2 *   (etaq - theta) / (beta - theta);
      j3 := jj3 *   (eta  - theta) * (beta - thetaq) / (theta - thetaq) ;

      if #{j1,j2,j3} eq 1 then
        // Do we have an involution?
        aut := I;
        order := 1;
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          order := 2;
        
          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
        end if;      

        autentries := [ ns*eta - 3*beta*eta*theta + beta*theta^2 + eta^2*theta,
                       -ns*eta^2 + ns*eta*theta - ns*theta^2 + beta*eta^2*theta + beta*eta*theta^2 - eta^2*theta^2,
                        ns - beta*eta - beta*theta + eta^2 - eta*theta + theta^2,
                       -ns*theta - beta*eta^2 + 3*beta*eta*theta - eta*theta^2];
        c := autentries[3];
        if c eq 0 then c := autentries[4]; end if;
        aut3 := Matrix(2,[K! (a/c) : a in autentries]);

        gen := aut*aut3;
        shortauts := [PGLreduce(gen^i) : i in [1..3*order-1]];
        rats := [(M[1,1]*x + M[1,2])/(M[2,1]*x + M[2,2]) : M in shortauts];
        dens := [(M[2,1]*x + M[2,2])^2 : M in shortauts]; 
        
        
        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
        
        for quad in quadratics do
          autgroup := [I];
          for i in [1..#rats] do
            quad2 := Numerator(Evaluate(quad,rats[i])*dens[i]);
            quad2 := quad2/Coefficient(quad2,Degree(quad2));
      
            if quad2 lt quad then continue quad; end if;
            if quad2 eq quad then
              autgroup cat:= [shortauts[i]];
            end if;
          end for;

          f := g*quad;
          checksum +:= 1/#autgroup; 
     
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
        continue theta;
      end if;
        
      if #{j1,j2,j3} eq 2 and j1 eq j2 then
        // do we have an involution?
        shortauts := [];
        aut := I;
        rat := x;
        den := 1;
        
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
          shortauts := [aut];
          rat := (aut[1,1]*x + aut[1,2])/(aut[2,1]*x + aut[2,2]);
          den := (aut[2,1]*x + aut[2,2])^2;
        end if;      

        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);

        if #shortauts eq 0 then
          for quad in quadratics do
            f := g*quad;
            checksum +:= 1; 
            autgroup := [I];
     
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        else
          for quad in quadratics do
            quad2 := Numerator(Evaluate(quad,rat)*den);
            quad2 := quad2/Coefficient(quad2,Degree(quad2));
            if quad2 lt quad then continue quad; end if;
            if quad2 eq quad then
              autgroup := [I,aut];
            else
              autgroup := [I];
            end if;
    
            f := g*quad;
            checksum +:= 1/#autgroup; 
     
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
        continue theta;
      end if;

      // So now the j's are distinct.
      if (j1 eq j2^q) or (j2 eq j3^q) or (j3 eq j1^q) then
        if j1 eq j2^q then
        // Do we have an involution?
          autgroup := [I];
          shortauts := [];
          aut := I;
          rat := x;
          den := 1;

          if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
            aut2eltseq := [
                          -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                           beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                          -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                           beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
            c:=aut2eltseq[3]; 
            if c eq 0 then c:=aut2eltseq[4]; end if;
            aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
            shortauts := [aut];
            rat := (aut[1,1]*x + aut[1,2])/(aut[2,1]*x + aut[2,2]);
            den := (aut[2,1]*x + aut[2,2])^2;
          end if;      

          aa := beta*(eta-theta);
          bb := eta*(theta-beta);
          cc := eta-theta;
          dd := theta-beta;

          g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
          if #shortauts eq 0 then
            for quad in quadratics do
              f := g*quad;
              checksum +:= 1; 
              autgroup := [I];
     
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end for;
          else
            for quad in quadratics do
              quad2 := Numerator(Evaluate(quad,rat)*den);
              quad2 := quad2/Coefficient(quad2,Degree(quad2));
              if quad2 lt quad then continue quad; end if;
              if quad2 eq quad then
                autgroup := [I,aut];
              else
                autgroup := [I];
              end if;
    
              f := g*quad;
              checksum +:= 1/#autgroup; 
     
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
           end for;
          end if;
        end if;
        continue theta;
      end if;
      
      p1 := MinimalPolynomial(j1,K);
      p2 := MinimalPolynomial(j2,K);
      p3 := MinimalPolynomial(j3,K);
      
      // These are distinct. Only continue to process if p1 is the smallest.
      
      if p1 eq Sort([p1,p2,p3])[1] then
      
        // Do we have an involution?
        shortauts := [];
        aut := I;
        rat := x;
        den := 1;
        if (normtheta+ns) * traceeta eq (normeta+ns) * tracetheta then
          aut2eltseq := [
                        -beta*normeta + ns*etaq - (normeta + ns)*thetaq + (beta + etaq)*normtheta,
                         beta*( (normeta - beta*etaq)*theta  + (normeta + beta*eta)*thetaq  - traceeta*normtheta),
                        -beta*traceeta + (beta + etaq)*theta + (beta - eta)*thetaq,
                         beta*normeta + ns*eta  - (normeta + ns)*theta  + (-beta + eta )*normtheta];
          c:=aut2eltseq[3]; 
          if c eq 0 then c:=aut2eltseq[4]; end if;
          aut := Matrix(2,[K!(a/c): a in aut2eltseq]);
          shortauts := [aut];
          rat := (aut[1,1]*x + aut[1,2])/(aut[2,1]*x + aut[2,2]);
          den := (aut[2,1]*x + aut[2,2])^2;
        end if;      

        aa := beta*(eta-theta);
        bb := eta*(theta-beta);
        cc := eta-theta;
        dd := theta-beta;

        g := MinimalPolynomial((aa*alpha + bb)/(cc*alpha + dd),K);
        if #shortauts eq 0 then
          for quad in quadratics do
            f := g*quad;
            checksum +:= 1; 
            autgroup := [I];
     
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        else
          for quad in quadratics do
            quad2 := Numerator(Evaluate(quad,rat)*den);
            quad2 := quad2/Coefficient(quad2,Degree(quad2));
            if quad2 lt quad then continue quad; end if;
            if quad2 eq quad then
              autgroup := [I,aut];
            else
              autgroup := [I];
            end if;
    
            f := g*quad;
            checksum +:= 1/#autgroup; 
     
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
      end if;
    end for;
  end for;
  
  assert checksum eq q^2 * (q^3 + q - 1) / 6;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;



//------------------------------------------------------------------------------

function genusthree71(K : passback := true, curves := true, output := false, outputfile := "", morethan71 := false)
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (7,1), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (7,1),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // If morethan71 = true, we include three other Galois types in the output:
  // types (5,2,1), (4,3,1), and (3,2,2,1). This is helpful, because allowing
  // these extra types greatly speeds up the computation, and if we are using
  // this function in order to produce *all* genus-3 hyperelliptic curves, we
  // can tell genusthree5x, genusthree4x, and genusthree3x to exclude these 
  // types from *their* output. All told, this speeds up the whole calculation.
  // We include these extra types by not sieving out quadratic factors and not
  // checking discriminants.

  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:

  // Galois type (7,1):          (q+1) * (q^2+q+1) * (q^2-q+1) / 7
  // Galois type (5,2,1):         q * (q^2+1) * (q+1) * (q-1) / 10
  // Galois type (4,3,1):         q^2 * (q+1)^2 * (q-1) / 12
  // Galois type (3,2,2,1):       q * (q+1)^2 * (q-1) * (q-2) / 24

  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well. In this case, all automorphism groups
  // will be trivial.
  
  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  I := Matrix(2,[K|1,0,0,1]);

  // We will put the single rational point of the divisor at infinity. Then all
  // we must do is is list degree-7 polynomials (or irreducible such) up to the
  // a*x + b group. In characteristic not 7, we do this by shifting so that the
  // trace is 0, and then scaling so that the polynomial has a normalized form.
  
  // If we are computing just the (7,1) examples, we make sure the degree-7
  // polynomial is irreducible by sieving out linear and quadratic factors; 
  // that's enough to reduce us to types (7,1) and (4,3,1). We eliminate the
  // latter by checking to see whether the discriminant is a square. 
  
  // In characteristic 7, if we have a polynomial that starts x^7 + a*x^d with
  // a nonzero and d > 1, then we can shift so that the coefficient of x^(d-1)
  // is 0. We scale as for other characteristics.
  
  checksum71 := 0;

  if 0 ne q mod 7 then
    // Characteristic other than 7.
    if morethan71 then
      // Return represenatatives (under the action of the ax+b group) for
      // degree-7 polynomials with no roots.
      for a5,a4,a3,a2,a1 in K do
        // Our polynomial begins x^7 + a5*x^5 + ...  + a1*x
        // Do these leading terms already give a normalized form?
        // We check a number of conditions.
        good := false;
        if a5 ne 0 and a4 ne 0 then
          if not a5 eq a4 then continue a1; else good:=true; end if;
        elif a5 ne 0 and a2 ne 0 then
          if not a2 eq a5^2 then continue a1; else good:=true; end if;
        elif a4 ne 0 and a3 ne 0 then
          if not a4 eq a3 then continue a1; else good:=true; end if;
        elif a4 ne 0 and a2 ne 0 then
          if not a4^2 eq a2 then continue a1; else good:=true; end if;
        elif a3 ne 0 and a2 ne 0 then
          if not a3 eq a2 then continue a1; else good:=true; end if;
        elif a2 ne 0 and a1 ne 0 then
          if not a2 eq a1 then continue a1; else good:=true; end if;
        end if;

        // If good is true, then we're normalized already!        
        
        if good then
          g := R![0,a1,a2,a3,a4,a5,0,1];
          // Compute the values of a0 such that g + a0 has a rational root.
          baduns := {-Evaluate(g,a) : a in K};
          
          // ...and run through possible constant terms, avoiding these
          // bad ones.

          // The divisors we get for these polynomials have trivial automorphism
          // groups.
          
          autgroup := [I];
          for a0 in K do 
            if not a0 in baduns then
              f := g + a0;
              if Discriminant(f) ne 0 then
                checksum71 +:= 1;
                if curves then
                  Cs := curves_from_divisor(f,autgroup);
                else
                  Cs := [<f,#autgroup,autgroup>];
                end if;

                for C in Cs do
                  if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                  if passback then Clist cat:= [C]; end if;
                end for;
              end if;
            end if;
          end for;
          continue a1;
        end if;
       
        // If we are here, then we have an initial polynomial that is not
        // already normalized. We need to compare it to all of its scalings
        // to see if it is smallest.

        gvec := [a5,a4,a3,a2,a1];
        auts := [];
        for a in K do
          if a ne 0 then
            hvec := [a5*a^2,a4*a^3,a3*a^4,a2*a^5,a1*a^6];
            if hvec lt gvec then continue a1; end if;
            if hvec eq gvec then auts cat:= [a]; end if;
          end if;
        end for;
        g := R![0,a1,a2,a3,a4,a5,0,1];
        baduns := {-Evaluate(g,a) : a in K};
        for a0 in K do 
          if not a0 in baduns then
            autgroup := [];
            for a in auts do
              if a0*a^7 lt a0 then continue a0; end if;          
              if a0*a^7 eq a0 then autgroup cat:= [Matrix(2,[a,0,0,1])]; end if; 
            end for;

            f := g + a0;
            if Discriminant(f) ne 0 then
              checksum71 +:= 1/#autgroup;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end if;
          end if;
        end for;
      end for;
      
    else
      // Return represenatatives (under the action of the ax+b group) for
      // irreducible degree-7 polynomials.

      quaddata := [ [Vector([ -b,     a*b, -a^2*b + b^2,     a^3*b - 2*a*b^2, -a^4*b + 3*a^2*b^2 - b^3, a^5*b - 4*a^3*b^2 + 3*a*b^3]),
                     Vector([ -a, a^2 - b, -a^3 + 2*a*b, a^4 - 3*a^2*b + b^2, -a^5 + 4*a^3*b - 3*a*b^2, a^6 - 5*a^4*b + 6*a^2*b^2 - b^3])] 
                     : a,b in K | not IsSquare(a^2-4*b)];
                     
      // These entries represent polynomials c*x + d such that c*x + d is 
      // congruent to x^i modulo x^2 + a*x + b, for i=2 up to i=7.
                     
      lindata := [ <a, Vector([a^2, a^3, a^4, a^5, a^6, a^7])> : a in K];
      
      // Similarly, values of x^i modulo x-a.
      
      for a5,a4,a3,a2 in K do
        // Our polynomial begins x^7 + a5*x^5 + ... + a2*x^2
        // Do these leading terms already give a normalized form?
        // We check a number of conditions.

        good := false;
        if a5 ne 0 and a4 ne 0 then
          if not a5 eq a4 then continue a2; else good:=true; end if;
        elif a5 ne 0 and a2 ne 0 then
          if not a2 eq a5^2 then continue a2; else good:=true; end if;
        elif a4 ne 0 and a3 ne 0 then
          if not a4 eq a3 then continue a2; else good:=true; end if;
        elif a4 ne 0 and a2 ne 0 then
          if not a4^2 eq a2 then continue a2; else good:=true; end if;
        elif a3 ne 0 and a2 ne 0 then
          if not a3 eq a2 then continue a2; else good:=true; end if;
        end if;

        // If good is true, then we're normalized already!        

        if good then
          vec := Vector([a2,a3,a4,a5,0,1]);
          g := x^7 + a5*x^5 + a4*x^4 + a3*x^3 + a2*x^2;
          
          // Compute the (negatives of the) reductions of this polynomial mod
          // all the irreducible quadratics. These tell us which linear terms
          // we have to avoid in order to keep the completed polynomial from
          // being divisible by an irreducible quadratic.
          
          baduns := { [-InnerProduct(vec,a[1]), -InnerProduct(vec,a[2])] : a in quaddata };

          // Now we do the same for linear polynomials.
          for a in lindata do
            value := InnerProduct(vec,a[2]);
            baduns join:= { [-b*a[1]-value, b] : b in K };
          end for;
          
          // If we avoid the linear terms represented by the elements of baduns,
          // we will get a polynomial with no linear or quadratic factors.
          
          // The divisors we get for these polynomails have trivial automorphism
          // groups.
          
          autgroup := [I];
          
          for a0,a1 in K do
            if not [a0,a1] in baduns then
              f := g + a0 + a1*x;
              // This polynomial is either irreducible, or a product of an
              // irreducible quartic and an irreducible cubic.
              // We tell the difference by looking at the square class of
              // the discriminant.
              D := Discriminant(f);
              if IsSquare(D) then
                checksum71 +:= 1;
                if curves then
                  Cs := curves_from_divisor(f,autgroup);
                else
                  Cs := [<f,#autgroup,autgroup>];
                end if;

                for C in Cs do
                  if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                  if passback then Clist cat:= [C]; end if;
                end for;
              end if;
            end if;
          end for;
          continue a2;
        end if;

        // If we are here, then we have an initial polynomial that is not
        // already normalized. We need to compare it to all of its scalings
        // to see if it is smallest.

        gvec := [a5,a4,a3,a2];
        auts := [];
        for a in K do
          if a ne 0 then
            hvec := [a5*a^2,a4*a^3,a3*a^4,a2*a^5];
            if hvec lt gvec then continue a2; end if;
            if hvec eq gvec then auts cat:= [a]; end if;
          end if;
        end for;
        g := R![0,0,a2,a3,a4,a5,0,1];
        vec := Vector([a2,a3,a4,a5,0,1]);
      
        // Compute the low-order terms to avoid.
        baduns := { [-InnerProduct(vec,a[1]), -InnerProduct(vec,a[2])] : a in quaddata };
        for a in lindata do
          value := InnerProduct(vec,a[2]);
          baduns join:= { [-b*a[1]-value, b] : b in K };
        end for;
    
        for a1, a0 in K do 
          if not [a0, a1] in baduns then
            autgroup := [];
            for a in auts do
              if [a1*a^6, a0*a^7] lt [a1,a0] then continue a0; end if;          
              if [a1*a^6, a0*a^7] eq [a1,a0] then autgroup cat:= [Matrix(2,[a,0,0,1])]; end if; 
            end for;
            f := g + a1*x + a0;
            D := Discriminant(f);
            if IsSquare(D) then
              checksum71 +:= 1/#autgroup;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end if;
          end if;
        end for;
      end for;
    end if;
  else
  
    // We are in characteristic 7.
    // The structure is similar to the above, but the normalization is 
    // different.
    
    if morethan71 then
      // Return represenatatives (under the action of the ax+b group) for
      // degree-7 polynomials with no roots.
      for a6 in [K|0,1], a5,a4,a3,a2,a1 in K do
        // Check to see that the action under translations has been 
        // accounted for. This includes treating the case 
        // a6=a5=a4=a3=a2=0 separately.
        
        // The automorphism groups will be trivial if we are not in the
        // special case a6=a5=a4=a3=a2=0.

        autgroup := [I];
        good := false;
        if a6 eq 1 then
          if a5 ne 0 then continue a1; end if;
          good:=true;
        elif a5 ne 0 then
          if a4 ne 0 then continue a1; end if;
          if a2 ne 0 then
            if a2 ne a5^2 then continue a1; else good:=true; end if;
          end if;
        elif a4 ne 0 then
          if a3 ne 0 then continue a1; end if;
          if a2 ne 0 then
            if a2 ne a4^2 then continue a1; else good:=true; end if;
          end if;
        elif a3 ne 0 then
          if a2 ne 0 then continue a1; end if;
        elif a2 ne 0 then
          if a1 ne 0 then continue a1; end if;
        else 
          // a6=a5=a4=a3=a2=0. Treat this elsewhere.
          continue a1;
        end if;

        // If good is true, then we're normalized already!        
        
        if good then
          g := R![0,a1,a2,a3,a4,a5,a6,1];
          // Compute the values of a0 such that g + a0 has a rational root.
          baduns := {-Evaluate(g,a) : a in K};
          
          // ...and run through possible constant terms, avoiding these
          // bad ones.

          for a0 in K do 
            if not a0 in baduns then
              f := g + a0;
              if Discriminant(f) ne 0 then
                checksum71 +:= 1;
                if curves then
                  Cs := curves_from_divisor(f,autgroup);
                else
                  Cs := [<f,#autgroup,autgroup>];
                end if;

                for C in Cs do
                  if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                  if passback then Clist cat:= [C]; end if;
                end for;
              end if;
            end if;
          end for;
          continue a1;
        end if;
       
        // If we are here, then we have an initial polynomial that is not
        // already normalized. We need to compare it to all of its scalings
        // to see if it is smallest.

        gvec := [a6,a5,a4,a3,a2,a1];
        auts := [];
        for a in K do
          if a ne 0 then
            hvec := [a6*a,a5*a^2,a4*a^3,a3*a^4,a2*a^5,a1*a^6];
            if hvec lt gvec then continue a1; end if;
            if hvec eq gvec then auts cat:= [a]; end if;
          end if;
        end for;
        g := R![0,a1,a2,a3,a4,a5,a6,1];
        baduns := {-Evaluate(g,a) : a in K};
        for a0 in K do 
          if not a0 in baduns then
            for a in auts do
              if a0*a^7 lt a0 then continue a0; end if;          
            end for;

            f := g + a0;
            if Discriminant(f) ne 0 then
              checksum71 +:= 1;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end if;
          end if;
        end for;
      end for;
      
      // Now, the special case a6=a5=a4=a3=a2=0. We must have a1 nonzero
      // for this to not have a root. And we must have a0 nonzero. So we
      // scale so that they are equal. 
      // So we have x^7 + a*x + a. This has a root exactly when there is a 
      // b such that a = -b^7/(b+1).
      
      baduns := {-b^7/(b+1) : b in K | b ne -1};
      for a1 in K do
        if not a1 in baduns then
          f := x^7 + a1*x + a1;
          autgroup := [Matrix(2,[1, r[1], 0, 1]) : r in Roots(x^7 + a1*x)];
          checksum71 +:= 1/#autgroup;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end if;
      end for;
          
          

    else
      // Return represenatatives (under the action of the ax+b group) for
      // irreducible degree-7 polynomials.

      quaddata := [ [Vector([ -b,     a*b, -a^2*b + b^2,     a^3*b - 2*a*b^2, -a^4*b + 3*a^2*b^2 - b^3, a^5*b - 4*a^3*b^2 + 3*a*b^3]),
                     Vector([ -a, a^2 - b, -a^3 + 2*a*b, a^4 - 3*a^2*b + b^2, -a^5 + 4*a^3*b - 3*a*b^2, a^6 - 5*a^4*b + 6*a^2*b^2 - b^3])] 
                     : a,b in K | not IsSquare(a^2-4*b)];
                     
      // These entries represent polynomials c*x + d such that c*x + d is 
      // congruent to x^i modulo x^2 + a*x + b, for i=2 up to i=7.
                     
      lindata := [ <a, Vector([a^2, a^3, a^4, a^5, a^6, a^7])> : a in K];
      
      // Similarly, values of x^i modulo x-a.
      
      for a6 in [K|0,1], a5,a4,a3,a2 in K do
        // Check to see that the action under translations has been 
        // accounted for. This includes treating the case 
        // a6=a5=a4=a3=a2=0 separately.
        
        // The automorphism groups will be trivial if we are not in the
        // special case a6=a5=a4=a3=a2=0.

        autgroup := [I];
        good := false;
        if a6 eq 1 then
          if a5 ne 0 then continue a2; end if;
          good:=true;
        elif a5 ne 0 then
          if a4 ne 0 then continue a2; end if;
          if a2 ne 0 then
            if a2 ne a5^2 then continue a2; else good:=true; end if;
          end if;
        elif a4 ne 0 then
          if a3 ne 0 then continue a2; end if;
          if a2 ne 0 then
            if a2 ne a4^2 then continue a2; else good:=true; end if;
          end if;
        elif a3 ne 0 then
          if a2 ne 0 then continue a2; end if;
        elif a2 eq 0 then
          // a6=a5=a4=a3=a2=0. Treat this elsewhere.
          continue a2;
        end if;

        // If good is true, then we're normalized already!        

        if good then
          vec := Vector([a2,a3,a4,a5,a6,1]);
          g := x^7 + a6*x^6 + a5*x^5 + a4*x^4 + a3*x^3 + a2*x^2;
          
          // Compute the (negatives of the) reductions of this polynomial mod
          // all the irreducible quadratics. These tell us which linear terms
          // we have to avoid in order to keep the completed polynomial from
          // being divisible by an irreducible quadratic.
          
          baduns := { [-InnerProduct(vec,a[1]), -InnerProduct(vec,a[2])] : a in quaddata };

          // Now we do the same for linear polynomials.
          for a in lindata do
            value := InnerProduct(vec,a[2]);
            baduns join:= { [-b*a[1]-value, b] : b in K };
          end for;
          
          // If we avoid the linear terms represented by the elements of baduns,
          // we will get a polynomial with no linear or quadratic factors.
                    
          // The divisors we get for these polynomails have trivial automorphism
          // groups.
          
          autgroup := [I];
          
          for a0,a1 in K do
            if not [a0,a1] in baduns then
              f := g + a0 + a1*x;
              // This polynomial is either irreducible, or a product of an
              // irreducible quartic and an irreducible cubic.
              // We tell the difference by looking at the square class of
              // the discriminant.
              D := Discriminant(f);
              if IsSquare(D) then
                checksum71 +:= 1;
                if curves then
                  Cs := curves_from_divisor(f,autgroup);
                else
                  Cs := [<f,#autgroup,autgroup>];
                end if;

                for C in Cs do
                  if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                  if passback then Clist cat:= [C]; end if;
                end for;
              end if;
            end if;
          end for;
          continue a2;
        end if;

        // If we are here, then we have an initial polynomial that is not
        // already normalized. We need to compare it to all of its scalings
        // to see if it is smallest.

        gvec := [a6,a5,a4,a3,a2];
        auts := [];
        for a in K do
          if a ne 0 then
            hvec := [a6*a,a5*a^2,a4*a^3,a3*a^4,a2*a^5];
            if hvec lt gvec then continue a2; end if;
            if hvec eq gvec then auts cat:= [a]; end if;
          end if;
        end for;
        g := R![0,0,a2,a3,a4,a5,a6,1];
        vec := Vector([a2,a3,a4,a5,a6,1]);
      
        // Compute the low-order terms to avoid.
        baduns := { [-InnerProduct(vec,a[1]), -InnerProduct(vec,a[2])] : a in quaddata };
        for a in lindata do
          value := InnerProduct(vec,a[2]);
          baduns join:= { [-b*a[1]-value, b] : b in K };
        end for;
        
        // But we also want to avoid the case where a6=a5=a4=a3=0
        // and a2 is nonzero and a1=0. So add some things to baduns if
        // a6=a5=a4=a3=0 and a2 is nonzero.
          
        if [a6,a5,a4,a3] eq [0,0,0,0] then
          baduns join:= { [a0, a1] : a0, a1 in K | a1 ne a2};
        end if;

    
        for a1, a0 in K do 
          if not [a0, a1] in baduns then
            for a in auts do
              if [a1*a^6, a0*a^7] lt [a1,a0] then continue a0; end if;          
            end for;
            f := g + a1*x + a0;
            D := Discriminant(f);
            if IsSquare(D) then
              checksum71 +:= 1;
              if curves then
                Cs := curves_from_divisor(f,autgroup);
              else
                Cs := [<f,#autgroup,autgroup>];
              end if;

              for C in Cs do
                if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
                if passback then Clist cat:= [C]; end if;
              end for;
            end if;
          end if;
        end for;
      end for;


      // Now, the special case a6=a5=a4=a3=a2=0. 
      // First, the regular old baduns:
      vec := Vector([K|0,0,0,0,0,1]);     

      // Compute the low-order terms to avoid.
      baduns := { [-InnerProduct(vec,a[1]), -InnerProduct(vec,a[2])] : a in quaddata };
      for a in lindata do
        value := InnerProduct(vec,a[2]);
        baduns join:= { [-b*a[1]-value, b] : b in K };
      end for;

      // But we must have a1 nonzero for this to not have a root. And we must
      // have a0 nonzero. So we scale so that they are equal.

      for a1 in K do
        if not [a1,a1] in baduns then
          f := x^7 + a1*x + a1;
          autgroup := [Matrix(2,[1, r[1], 0, 1]) : r in Roots(x^7 + a1*x)];
          checksum71 +:= 1/#autgroup;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end if;
      end for;

    end if;
  end if;

  if not morethan71 then
    assert checksum71 eq (q+1) * (q^2+q+1) * (q^2-q+1) / 7;
  else
    assert checksum71 eq (q+1) * (103*q^4 - 154/3*q^3 + 33*q^2 - 14/3*q + 40) / 280;
  end if;
  
  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;

//------------------------------------------------------------------------------

function genusthree8(K : passback := true, curves := true, output := false, outputfile := "")
  // K is a finite field of size q = p^e, with p odd.
  // Compute representatives of either
  //    (a) all isomorphism classes of genus-3 hyperelliptic curves over K with 
  //        Weierstrass divisor of Galois type (8), or
  //    (b) all PGL(2,K) orbits of divisors of P^1 of Galois type (8),
  // depending on whether curves = true or curves = false.
  
  // If passback = true, we return the set of representatives; otherwise we
  // return an empty list.
  
  // If output = true, we print the representatives as they are computed.
  // We print to standard out if outputfile = ""; otherwise, we print to 
  // the named file.
  
  // In any case, the sum, over all representatives of a given Galois type, of 1
  // over the size of the automorphism group of the representative should be as
  // follows:

  // Galois type (8):   q^3 * (q^2+1) / 8 

  // We include the size of the automorphism group of each representative as 
  // part of the output. If we are passing back a list, we include the
  // automorphism group itself, as well. In this case, all automorphism groups
  // will be trivial.

  if outputfile ne "" then
    SetOutputFile(outputfile);
  end if;

  checksum8 := 0;
  Clist := [];
  q := #K;
  R<x>:=PolynomialRing(K);
  ns := nonsquare(K);
  I := Matrix(2,[K|1,0,0,1]);
  
  // Get the quadratic extension of K
  L<beta>:=ext<K | x^2 - ns>;
  nsL := nonsquare(L);
  S<y>:=PolynomialRing(L);

  // Get the quartics over L up to PGL2(L). This takes space O(q^2).
  quartics := fourpoints4(L : ns := nsL);

  // However, we only want the quartics up to conjugation over K.
  quartics := [a : a in quartics | cross(a[1]) le cross(S![c^q : c in Eltseq(a[1])])];
  
  // There are three automorphism groups of these quartics. Two have order 2,
  // and their nontrivial elements are one of the following:
  
  involutionrat := Matrix(2,[L|0,1,1,0]);    // involution with rational fixed points.
  involutionirrat := Matrix(2,[0,nsL,1,0]);  // involution with irrational fixed points.

  quarticsrat := [a[1] : a in quartics | a[2] eq 2 and involutionrat in a[3]];
  quarticsirrat := [a[1] : a in quartics | a[2] eq 2 and involutionirrat in a[3]];
  special := [a : a in quartics | a[2] eq 4];
  
  assert #quartics eq #quarticsrat + #quarticsirrat + #special;
  assert #special eq 1;
  
  // Since q^2 = 1 mod 4, we can replace the special quartic with one that
  // is more concrete.
  
  specialf := y^4 - nsL;
  // We will need to know the elements of PGL that take specialf either to
  // itself or to its conjugate over K. Don't bother including the identity.
  
  zeta4 := Roots(x^2 + 1,L)[1][1];
  partialauts := [Matrix(2,[zeta4^i,0,0,1]) : i in [1..3]];
  // partialauts consists of automorphisms of specialf other then the identity.

  case q mod 4:
    when 1:
      r := nsL^((q-1) div 4);
      semiauts := [Matrix(2,[zeta4^i*r,0,0,1]) : i in [0..3]];
    when 3:
      r := nsL^((q+1) div 4);
      semiauts := [Matrix(2,[0, zeta4^i*r, 1, 0]) : i in [0..3]];
  end case;
  // semiauts consists of elements if PGL2 that take specialf to its conjugate.

    
  // We want to have representatives for PSL(2,q)\PSL(2,q^2)/A, for the
  // possible quartic automorphism groups A. So we first compute
  // representatives for PSL(2,q)\PSL(2,q^2). For each such element X we
  // compute the orbit labels of X and X*a for a in A. We only continue on 
  // with an X if its orbit label is the smallest of these. And we do this
  // all in parallel for the different automorphism groups.
  
  // We use Proposition 5.1 of [Howe2025]. If you are reading these comments,
  // you should look up that result if you want to know what is going on here.
  // However, the argument in the proof of Proposition 5.1 is also sketched
  // in the comments interspersed in the code.

  // We label elements of PGL(2,*) by specifying where they send oo, 0, and 1. 
  
  // Suppose we have the element of PGL(2,L) that sends [oo,0,1] to
  // [zeta, eta, theta]. By operating with PGL(2,K), we can assume that
  // zeta is either oo or beta.
  
  // [zeta = oo]: We can still act by the a*x+b group. So we can assume
  // that eta is either 0 or beta.
  
  // [zeta = oo, eta = 0]: We can still scale by elements of K. So we can 
  // assume that theta is either 1 or beta + a for an element of K.
  
  // Representatives:
  // [oo, 0, 1] and [oo, 0, beta + a] for a in K.
  // q + 1 elements.
  // Matrices: [1,0,0,1], [beta+a,0,0,1]
  
  // [zeta = oo, eta = beta]: No available actions left, so theta can be 
  // any element of L that is not beta.
  
  // Representatives:
  // [oo, beta, theta] for theta in L with theta != beta.
  // q^2 - 1 elements.
  // Matrices: [theta-beta, beta, 0, 1]
  
  // [zeta = beta]: We can act by elements of PGL(2,K) that fix beta.
  // eta can be any orbit representative of the action of this group 
  // on P^1(L). For the large orbits we obtain these from the function
  // betaorbitreps. The only trivial orbit allowable is {-beta}.

  // [zeta = beta, eta = -beta]: We can still act by the elements of PGL(2,K)
  // that fix beta because they fix -beta as well. So now choose theta from
  // the orbit representatives from betaorbitreps.

  //  Representatives:
  // [beta, -beta, theta] for theta in orbitreps.
  // q - 1 elements.
  // Matrices: [beta*(beta+theta), beta*(theta-beta), beta+theta, beta-theta]
  
  
  // [zeta = beta, eta in orbitreps]:
  // Representatives:
  // [beta, eta, theta] for eta in orbit reps and theta in P^1(L) with
  // theta not equal to beta or eta.
  // q - 1 choices for eta, q^2 - 1 choices for theta.
  // Matrices: [beta*(eta-theta), eta*(theta-beta), eta-theta, theta-beta]
  // And (when theta = oo):
  // [beta, -eta, 1, -1]
  
  
  // In the following, we specify in comments where oo, 0, and 1 get send to:
  
  // oo, 0, 1
  mat := Matrix(2,[L!1, 0, 0, 1]);
  baselabel := orbitlabel(K,L,beta,mat);
  rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

  // Process this. We will see this code snippet a lot!
  // Quartics whose involutions have K-rational fixed points:
  if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
    for h in quarticsrat do
      g := Numerator(Evaluate(h,rat));
      g := g/Coefficient(g,4);
      gq := S![a^q : a in Coefficients(g)];
      f := R!(g*gq);

      autgroup := [I];
      newinvolution := PGLreduce(mat*involutionrat*mat^-1);
      if &and[a in K : a in Eltseq(newinvolution)] then
        newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
        autgroup cat:= [newinv];
      end if;
    
      checksum8 +:= 1/#autgroup;
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end if;

  // Quartics whose involutions do not have K-rational fixed points:
  if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
    for h in quarticsirrat do
      g := Numerator(Evaluate(h,rat));
      g := g/Coefficient(g,4);
      gq := S![a^q : a in Coefficients(g)];
      f := R!(g*gq);

      autgroup := [I];
      newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
      if &and[a in K : a in Eltseq(newinvolution)] then
        newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
        autgroup cat:= [newinv];
      end if;
    
      checksum8 +:= 1/#autgroup;
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end for;
  end if;

  // The special quartic:
  good := true;
  for M in partialauts do
    if baselabel gt orbitlabel(K,L,beta,mat*M) then
      good := false;
      break M;
    end if;
  end for;

  if good then
    matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
    for M in semiauts do
      if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
        good := false;
        break M;
      end if;
    end for;
  end if;    

  if good then 
    g := Numerator(Evaluate(specialf,rat));
    g := g/Coefficient(g,4);
    gq := S![a^q : a in Coefficients(g)];
    f := R!(g*gq);

    matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
  
    // Now compute the automorphism group.
    autgroup := [I];
    for A in partialauts do
      B := PGLreduce(mat*A*matinv);
      if &and[z in K : z in Eltseq(B)] then
        B := Matrix(2,[K!z : z in Eltseq(B)]);
        autgroup cat:= [B];
      end if;
    end for;
    
    for A in semiauts do
      B := PGLreduce(matsigma*A*matinv);
      if &and[z in K : z in Eltseq(B)] then
        B := Matrix(2,[K!z : z in Eltseq(B)]);
        autgroup cat:= [B];
      end if;
    end for;
  
    checksum8 +:= 1/#autgroup;
    if curves then
      Cs := curves_from_divisor(f,autgroup);
    else
      Cs := [<f,#autgroup,autgroup>];
    end if;

    for C in Cs do
      if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
      if passback then Clist cat:= [C]; end if;
    end for;
  end if;        
    

  // oo, 0, beta + a
  for a in K do
    mat := Matrix(2,[beta+a, 0, 0, 1]);
    baselabel := orbitlabel(K,L,beta,mat);
    rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

    // Process this. We will see this code snippet a lot!
    // Quartics whose involutions have K-rational fixed points:
    if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
      for h in quarticsrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    
    // Quartics whose involutions do not have K-rational fixed points:
    if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
      for h in quarticsirrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    
    // The special quartic:
    good := true;
    for M in partialauts do
      if baselabel gt orbitlabel(K,L,beta,mat*M) then
        good := false;
        break M;
      end if;
    end for;

    if good then
      matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
      for M in semiauts do
        if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
          good := false;
          break M;
        end if;
      end for;
    end if;    

    if good then 
      g := Numerator(Evaluate(specialf,rat));
      g := g/Coefficient(g,4);
      gq := S![a^q : a in Coefficients(g)];
      f := R!(g*gq);

      matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
    
      // Now compute the automorphism group.
      
      autgroup := [I];
      for A in partialauts do
        B := PGLreduce(mat*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
      
      for A in semiauts do
        B := PGLreduce(matsigma*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
    
      checksum8 +:= 1/#autgroup;
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end if;        
    
  end for;
    
  // oo, beta, theta    for theta in L with theta != beta.
  for theta in L do
    if not theta eq beta then
      mat := Matrix(2,[theta-beta, beta, 0, 1]);
      baselabel := orbitlabel(K,L,beta,mat);
      rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

      // Process this. We will see this code snippet a lot!
      // Quartics whose involutions have K-rational fixed points:
      if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
        for h in quarticsrat do
          g := Numerator(Evaluate(h,rat));
          g := g/Coefficient(g,4);
          gq := S![a^q : a in Coefficients(g)];
          f := R!(g*gq);

          autgroup := [I];
          newinvolution := PGLreduce(mat*involutionrat*mat^-1);
          if &and[a in K : a in Eltseq(newinvolution)] then
            newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
            autgroup cat:= [newinv];
          end if;
        
          checksum8 +:= 1/#autgroup;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
      // Quartics whose involutions do not have K-rational fixed points:
      if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
        for h in quarticsirrat do
          g := Numerator(Evaluate(h,rat));
          g := g/Coefficient(g,4);
          gq := S![a^q : a in Coefficients(g)];
          f := R!(g*gq);

          autgroup := [I];
          newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
          if &and[a in K : a in Eltseq(newinvolution)] then
            newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
            autgroup cat:= [newinv];
          end if;
        
          checksum8 +:= 1/#autgroup;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end for;
      end if;
      // The special quartic:
      
      good := true;
      for M in partialauts do
        if baselabel gt orbitlabel(K,L,beta,mat*M) then
          good := false;
          break M;
        end if;
      end for;

      if good then
        matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
        for M in semiauts do
          if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
            good := false;
            break M;
          end if;
        end for;
      end if;    

      if good then 
        g := Numerator(Evaluate(specialf,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
      
        // Now compute the automorphism group.
        
        autgroup := [I];
        for A in partialauts do
          B := PGLreduce(mat*A*matinv);
          if &and[z in K : z in Eltseq(B)] then
            B := Matrix(2,[K!z : z in Eltseq(B)]);
            autgroup cat:= [B];
          end if;
        end for;
        
        for A in semiauts do
          B := PGLreduce(matsigma*A*matinv);
          if &and[z in K : z in Eltseq(B)] then
            B := Matrix(2,[K!z : z in Eltseq(B)]);
            autgroup cat:= [B];
          end if;
        end for;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end if;        

    end if;
  end for;

  orbitreps := betaorbitreps(K,beta);
    
  // beta, -beta, theta for theta in orbitreps.
  for theta in orbitreps do
    mat := Matrix(2,[beta*(beta+theta), beta*(theta-beta), beta+theta, beta-theta]);

    baselabel := orbitlabel(K,L,beta,mat);
    rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

    // Process this. We will see this code snippet a lot!
    // Quartics whose involutions have K-rational fixed points:
    if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
      for h in quarticsrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    // Quartics whose involutions do not have K-rational fixed points:
    if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
      for h in quarticsirrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    // The special quartic:
    
    good := true;
    for M in partialauts do
      if baselabel gt orbitlabel(K,L,beta,mat*M) then
        good := false;
        break M;
      end if;
    end for;

    if good then
      matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
      for M in semiauts do
        if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
          good := false;
          break M;
        end if;
      end for;
    end if;    

    if good then 
      g := Numerator(Evaluate(specialf,rat));
      g := g/Coefficient(g,4);
      gq := S![a^q : a in Coefficients(g)];
      f := R!(g*gq);

      matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
    
      // Now compute the automorphism group.
      
      autgroup := [I];
      for A in partialauts do
        B := PGLreduce(mat*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
      
      for A in semiauts do
        B := PGLreduce(matsigma*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
    
      checksum8 +:= 1/#autgroup;
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end if;        
        
  end for;

  // beta, eta, oo   for eta in orbit reps
  for eta in orbitreps do
    mat := Matrix(2,[beta, -eta, 1, -1] );
    baselabel := orbitlabel(K,L,beta,mat);
    rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

    // Process this. We will see this code snippet a lot!
    // Quartics whose involutions have K-rational fixed points:
    if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
      for h in quarticsrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    // Quartics whose involutions do not have K-rational fixed points:
    if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
      for h in quarticsirrat do
        g := Numerator(Evaluate(h,rat));
        g := g/Coefficient(g,4);
        gq := S![a^q : a in Coefficients(g)];
        f := R!(g*gq);

        autgroup := [I];
        newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
        if &and[a in K : a in Eltseq(newinvolution)] then
          newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
          autgroup cat:= [newinv];
        end if;
      
        checksum8 +:= 1/#autgroup;
        if curves then
          Cs := curves_from_divisor(f,autgroup);
        else
          Cs := [<f,#autgroup,autgroup>];
        end if;

        for C in Cs do
          if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
          if passback then Clist cat:= [C]; end if;
        end for;
      end for;
    end if;
    // The special quartic:
    
    good := true;
    for M in partialauts do
      if baselabel gt orbitlabel(K,L,beta,mat*M) then
        good := false;
        break M;
      end if;
    end for;

    if good then
      matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
      for M in semiauts do
        if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
          good := false;
          break M;
        end if;
      end for;
    end if;    

    if good then 
      g := Numerator(Evaluate(specialf,rat));
      g := g/Coefficient(g,4);
      gq := S![a^q : a in Coefficients(g)];
      f := R!(g*gq);

      matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
    
      // Now compute the automorphism group.
      
      autgroup := [I];
      for A in partialauts do
        B := PGLreduce(mat*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
      
      for A in semiauts do
        B := PGLreduce(matsigma*A*matinv);
        if &and[z in K : z in Eltseq(B)] then
          B := Matrix(2,[K!z : z in Eltseq(B)]);
          autgroup cat:= [B];
        end if;
      end for;
    
      checksum8 +:= 1/#autgroup;
      if curves then
        Cs := curves_from_divisor(f,autgroup);
      else
        Cs := [<f,#autgroup,autgroup>];
      end if;

      for C in Cs do
        if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
        if passback then Clist cat:= [C]; end if;
      end for;
    end if;        
    
  end for;


  // beta, eta, theta   for eta in orbit reps and theta in L\{beta,eta}
  for eta in orbitreps do
    for theta in L do
      if theta ne beta and theta ne eta then
        mat := Matrix(2,[beta*(eta-theta), eta*(theta-beta), eta-theta, theta-beta]);

        baselabel := orbitlabel(K,L,beta,mat);
        rat := (mat[2,2]*y - mat[1,2])/(-mat[2,1]*y + mat[1,1]);

        // Process this. We will see this code snippet a lot!
        // Quartics whose involutions have K-rational fixed points:
        if baselabel le orbitlabel(K,L,beta,mat*involutionrat) then 
          for h in quarticsrat do
            g := Numerator(Evaluate(h,rat));
            g := g/Coefficient(g,4);
            gq := S![a^q : a in Coefficients(g)];
            f := R!(g*gq);

            autgroup := [I];
            newinvolution := PGLreduce(mat*involutionrat*mat^-1);
            if &and[a in K : a in Eltseq(newinvolution)] then
              newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
              autgroup cat:= [newinv];
            end if;
          
            checksum8 +:= 1/#autgroup;
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
        // Quartics whose involutions do not have K-rational fixed points:
        if baselabel  le orbitlabel(K,L,beta,mat*involutionirrat) then 
          for h in quarticsirrat do
            g := Numerator(Evaluate(h,rat));
            g := g/Coefficient(g,4);
            gq := S![a^q : a in Coefficients(g)];
            f := R!(g*gq);

            autgroup := [I];
            newinvolution := PGLreduce(mat*involutionirrat*mat^-1);
            if &and[a in K : a in Eltseq(newinvolution)] then
              newinv := Matrix(2,[K!a : a in Eltseq(newinvolution)]);
              autgroup cat:= [newinv];
            end if;
          
            checksum8 +:= 1/#autgroup;
            if curves then
              Cs := curves_from_divisor(f,autgroup);
            else
              Cs := [<f,#autgroup,autgroup>];
            end if;

            for C in Cs do
              if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
              if passback then Clist cat:= [C]; end if;
            end for;
          end for;
        end if;
        // The special quartic:
        
        good := true;
        for M in partialauts do
          if baselabel gt orbitlabel(K,L,beta,mat*M) then
            good := false;
            break M;
          end if;
        end for;

        if good then
          matsigma := Matrix(2,[a^q : a in Eltseq(mat)]);
          for M in semiauts do
            if baselabel gt orbitlabel(K,L,beta,matsigma*M) then
              good := false;
              break M;
            end if;
          end for;
        end if;    

        if good then 
          g := Numerator(Evaluate(specialf,rat));
          g := g/Coefficient(g,4);
          gq := S![a^q : a in Coefficients(g)];
          f := R!(g*gq);

          matinv := Matrix(2,[mat[2,2],-mat[1,2],-mat[2,1],mat[1,1]]);
        
          // Now compute the automorphism group.
          
          autgroup := [I];
          for A in partialauts do
            B := PGLreduce(mat*A*matinv);
            if &and[z in K : z in Eltseq(B)] then
              B := Matrix(2,[K!z : z in Eltseq(B)]);
              autgroup cat:= [B];
            end if;
          end for;
          
          for A in semiauts do
            B := PGLreduce(matsigma*A*matinv);
            if &and[z in K : z in Eltseq(B)] then
              B := Matrix(2,[K!z : z in Eltseq(B)]);
              autgroup cat:= [B];
            end if;
          end for;
        
          checksum8 +:= 1/#autgroup;
          if curves then
            Cs := curves_from_divisor(f,autgroup);
          else
            Cs := [<f,#autgroup,autgroup>];
          end if;

          for C in Cs do
            if output then printf "%o, %o\n", Eltseq(C[1]),C[2]; end if; 
            if passback then Clist cat:= [C]; end if;
          end for;
        end if;        

      end if;
    end for;
  end for;

  assert checksum8 eq q^3 * (q^2 + 1) / 8;

  if outputfile ne "" then
    UnsetOutputFile();
  end if;

  return Clist;
end function;


/*
================================================================================
Functions for getting all hyperelliptic curves of genus three.
================================================================================
*/

function hyperelliptic3(K : passback := true, curves := true, output := false, outputfile := "", efficient := true);
  // Return the union of the output of all the various genusthreexx functions.
  // Note that we modify some functions by setting flags:
  // we ask genusthree5x to not include Galois type (5,2,1),
  // we ask genusthree4x to not include Galois type (4,3,1),
  // we ask genusthree3x to not include Galois type (3,2,2,1),
  // and we ask genusthree71 to include those Galois types.
  // The net effect is increased speed.

  
  Clist    := genusthree8 (K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genusthree71(K : passback := passback, curves := curves, output := output, outputfile := outputfile, morethan71 := efficient);
  Clist cat:= genusthree6x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genusthree5x(K : passback := passback, curves := curves, output := output, outputfile := outputfile, skip521 := efficient);
  Clist cat:= genusthree4x(K : passback := passback, curves := curves, output := output, outputfile := outputfile, skip431 := efficient);
  Clist cat:= genusthree3x(K : passback := passback, curves := curves, output := output, outputfile := outputfile, skip3221 := efficient);
  Clist cat:= genusthree2x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  Clist cat:= genusthree1x(K : passback := passback, curves := curves, output := output, outputfile := outputfile);
  return Clist;
end function;


/*
================================================================================
Functions for verifying that output of hyperelliptic3 is correct.
================================================================================
*/


function invariant31(cubic,linear)
  // We compute a quantity that almost, but not quite, distinguishes the 
  // PGL(2,K) orbits of homogeneous quartics that are a product of a linear
  // polynomial with an irreducible cubic.
  
  // First, we move the root of the linear factor to infinity. If the cubic
  // is thereby transformed to x^3 + a*x^2 + b*x + c, we return the value
  // (a^2-3*b)^3/Disc(cubic). This almost, but not quite, distinguishes cubics
  // up to the action of the a*x + b group: it does not distinguish x^3 - a 
  // from x^3 - a^2 in characteristic not 3.

  R := Parent(cubic);
  x := R.1;
  c,b,a,one := Explode(Coefficients(cubic));
  disc := Discriminant(cubic);
  disc2 := (a^2 - 3*b);
  if Degree(linear) eq 1 then
    d := Roots(linear)[1][1];
    N := d^2*disc2 + a*b*d - 3*a*c + b^2 - 9*c*d;
    res := Evaluate(cubic,d);
    return N^3/res^2/disc;
  end if;
  return disc2^3/disc;
end function;


function signature(f)
  // Compute a "signature" of a hyperelliptic curve of given by an equation
  // y^2 = f for a separable polynomial f. The signature will be composed of:
  //  * The number of points on the curve over the base field and over the
  //    extension fields of degree 2 and 3;
  //  * The degrees of the irreducible factors of the homogenization g of f;
  //  * The cross polynomials of the irreducible factors of degree at least 4;
  //  * The invariants of all cubic-times-linear factors of g, computed using
  //    the function invariant31();
  //  * The mu invariants of all quadratic-times-quadratic factors of g;
  //  * The mu invariants of all quadratic-times-two-linear factors of g;
  //  * The j-invariants of all split quartic factors of g.
  
  // The goal is to have something that is relatively easy to compute and that
  // will let us quickly proof that two curves are *not* isomorphic to one
  // another.

  R := Parent(f);
  K := BaseRing(R);
  L := ext<K|2>;
  M := ext<K|3>;
  C := HyperellipticCurve(f);
  CL := BaseExtend(C,L);
  CM := BaseExtend(C,M);
  points := [#C, #CL, #CM];

  ff := Factorization(f);
  alldegs := [Degree(g[1]) : g in ff];
  deg3 := [g[1] : g in ff | Degree(g[1]) eq 3];
  deg2 := [g[1] : g in ff | Degree(g[1]) eq 2];
  deg1 := [g[1] : g in ff | Degree(g[1]) eq 1];

  if 1 eq Degree(f) mod 2 then
    deg1 cat:= [R!1];
    alldegs cat:= [1];
  end if;
  Sort(~alldegs);

  crosspolys := {cross(g[1]) : g in ff | Degree(g[1]) gt 3};

  j31 := Sort([invariant31(a,b) : a in deg3, b in deg1]);
  j22 := Sort([mu_invariant(a,b) : a,b in deg2 | a lt b]);
  j211 := Sort([mu_invariant(a,b*c) : a in deg2, b, c in deg1 | b lt c and b ne 1]);
  j1111 := Sort([j_quartic(a*b*c*d) : a,b,c,d in deg1 | a lt b and b lt c and c lt d]);

  return <points, alldegs , crosspolys, j31, j22, j211, j1111>;
end function;


procedure progress(~percentage, n, N)
  newpercentage := Round(100*n/N);
  if newpercentage ne percentage then
    percentage := newpercentage;
    printf "%oPercent complete: %o", CodeToString(13), percentage;
    if percentage eq 100 then print ""; end if;
  end if;
end procedure;
  
function verify(K : efficient:=true, verbose:=true);
  // Verify that hyperelliptic3() produces correct results, whether or not
  // the "efficient" is set.
  
  // We take the output of hyperelliptic3(K) and do the following:
  
  // We check that all of the curves are distinct. To do this, we compute
  // (hashes of) the signature of each curve, and for each pair of curves
  // with matching signatures, we run an isomorphism test.
  
  // We check that the automorphism groups of the curves were computed 
  // correctly. This means that we check:
  //   * Does the number of automorphisms as given by the second element of
  //     each output triple match the number as computed by
  //     IsIsomorphicHyperellipticCurves?
  //   * Does the second element of each output triple equal twice the 
  //     cardinality of the third element?
  //   * Does every matrix in the third element take the first element to
  //     itself?
  
  // And we check that the sum of the inverses of the automorphism group orders
  // is equal to q^3.
  
  // As soon as we find a problem, we abort.
  
  // As of March 2025, there is an error in IsIsomorphicHyperellipticCurves()
  // that caused the function to break in certain cases when the degree of its
  // first argument is one less than the degree of its second argument.
  // We avoid this by calling the function with the arguments swapped, if 
  // necessary.
  

  R<x>:=PolynomialRing(K);
  good := true;
  for flag in [true, false] do
    print "==================================";
    if flag then 
      print "Computing curves efficiently.";
    else
      print "Computing curves less efficiently.";
    end if;
    time L := hyperelliptic3(K : efficient:=flag);
  
  
    print "\nComputing signatures of the curves.";
    invs := [];
    percentdone := 0;
    count := 0;
    time for C in L do
      count+:=1; 
      if verbose then progress(~percentdone,count,#L); end if;
      invs cat:= [Hash(signature(C[1]))];
    end for;
  
    print "\nLooking for isomorphic curves.";
  
    ParallelSort(~invs,~L);
    percentdone := 0;
    time for i in [1..#invs-1] do 
      if verbose then progress(~percentdone,i,#invs); end if;
      f1 := L[i][1];
      j := i+1;
      while j le #invs and invs[i] eq invs[j] do
        f2 := L[j][1];
        if Degree(f1) eq 8 then
          bool := IsIsomorphicHyperellipticCurves(f1,f2);
        else
          bool := IsIsomorphicHyperellipticCurves(f2,f1);
        end if;

        if bool then
          print L[i], L[j]; 
          good := false;
          break flag;
        end if;

        j+:=1;
      end while;
    end for;
  
    print "\nChecking sizes of automorphism groups.";
    percentdone := 0;
    count := 0;
    time for a in L do
      count +:=1; 
      if verbose then progress(~percentdone,count,#L); end if;
      bool, auts := IsIsomorphicHyperellipticCurves(a[1],a[1]);
      if not a[2] eq #auts or not a[2] eq 2*#a[3] then
        print a;
        good := false;
        break flag;
      end if;
    end for;

    print "\nChecking elements of automorphism groups.";
    percentdone := 0;
    count := 0;
    time for a in L do
      count +:=1; 
      if verbose then progress(~percentdone,count,#L); end if;
      ca := Coefficient(a[1],Degree(a[1]));
      for b in a[3] do
        g := Numerator(Evaluate(a[1],(b[1,1]*x + b[1,2])/(b[2,1]*x + b[2,2]))
                       * (b[2,1]*x + b[2,2])^8);
        cg := Coefficient(g,Degree(g));
        if not ca*g eq cg*a[1] or not IsSquare(ca*cg) then
          print a;
          good := false;
          break flag;
        end if;
      end for;
    end for;

    print "\nChecking weighted cardinality of all curves.";
    good := (#K)^5 eq &+[1/a[2] : a in L];

  end for;
  
  if good then
    print "\nEverything checks out! The function hyperelliptic3 gives correct";
  else
    print "\nSomething went wrong: The function hyperelliptic3 gives incorrect";
  end if;
  printf "output for the %o.\n", K;
  
  return good;
end function;
